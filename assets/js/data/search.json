[ { "title": "람다식(Lambda)", "url": "/posts/Lambda/", "categories": "Java", "tags": "Java, 람다식, Lambda", "date": "2022-10-28 00:00:00 +0900", "snippet": "람다식이란?메서드를 하나의 식(expression)으로 표현한 것이다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 익명함수라고도 한다.람다식 도입으로 인해 자바는 객체지향언어인 동시에 함수형 언어가 되었다.int[] arr = new int[5];Arrays.setAll(arr, (i) -&gt; (int)(Math.random() * 5) + 1); // arr=[1,5,2,1,1]위에 람다식을 메서드로 표현하면 다음과 같다.int method() {\treturn (int)(Math.random() * 5) + 1;}간결하면서도 이해하기 쉽고, 오직 람다식 자체만으로도 메서드의 역할을 대신할 수 있다. 게다가 메서드의 매개변수로 전달되어지는 것이 가능하고 결과로 반환될 수도 있다.람다식 작성하기메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 -&gt;를 추가한다.// 메서드반환타입 메서드이름(매개변수 선언) {\t문장들}// 람다식(매개변수 선언) -&gt; {\t문장들}예를 들어 메서드 max를 람다식으로 변환하면, 아래의 오른쪽과 같이 된다.int max(int a, int b) {\treturn a &gt; b ? a : b;}(int a, int b) -&gt; {\treturn a &gt; b ? a : b;}반환값이 있는 메서드의 경우, return문 대신 식(expression)으로 대신 할 수 있다.(int a, int b) -&gt; { return a &gt; b ? a : b; }(int a, int b) -&gt; a &gt; b ? a : b매개변수의 타입은 추론이 가능한 경우는 생략할 수 있는데, 대부분의 경우에 생략가능하다. 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.(int a, int b) -&gt; a &gt; b ? a : b(a, b) -&gt; a &gt; b ? a : b매개변수가 하나뿐인 경우에는 괄호()를 생략할 수 있다. 단, 매개변수 타입이 있으면 생략할 수 없다.(a) -&gt; a * a(int a) -&gt; a * aa -&gt; a * a // OKint a -&gt; a * a // 에러괄호{}안의 문장이 하나일 때는 괄호{}를 생략할 수 있다. 이 때 세미콜론(;)을 붙이지 않는다.(String name, int i) -&gt; {\tSystem.out.println(name + \"=\" + i);}(String name, int i) -&gt;\tSystem.out.println(name + \"=\" + i)그러나 괄호{}안의 문장이 return문일 경우 생략할 수 없다.(int a, int b) -&gt; { return a &gt; b ? a : b; } // OK(int a, int b) -&gt; return a &gt; b ? a : b; // 에러아래는 왼쪽 메서드를 오른쪽 람다식으로 변환하는 예제이다.int max(int a, int b) {\treturn a &gt; b ? a : b;}// ====================================void printVar(String name, int i) {\tSystem.out.println(name + \"=\" + i);}// ====================================int square(int x) {\treturn x * x;}// ====================================int roll() {\treturn (int)(Math.random() * 6);}// ====================================int sumArr(int[] arr) {\tint sum = 0;\tfor(int i : arr)\t\tsum += i;\treturn sum;}(int a, int b) -&gt; { return a &gt; b ? a : b; }(int a, int b) -&gt; a &gt; b ? a : b(a, b) -&gt; a &gt; b ? a : b// ====================================(String name, int i) -&gt; { System.out.println(name + \"=\" + i); }(name, i) -&gt; { System.out.println(name + \"=\" + i); }(name, i) -&gt; System.out.println(name + \"=\" + i)// ====================================(int x) -&gt; x * x(x) -&gt; x * xx -&gt; x * x// ====================================() -&gt; { return (int)(Math.random() * 6); }() -&gt; (int)(Math.random() * 6)// ====================================(int[] arr) -&gt; {\tint sum = 0;\tfor(int i : arr)\t\tsum += i;\treturn sum;}함수형 인터페이스(Functional Interface)람다식은 익명 클래스의 객체와 동등하다.(int a, int b) -&gt; a &gt; b ? a : bnew Object() {\tint max(int a, int b) {\t\treturn a &gt; b ? a : b;\t}}예를 들어 MyFunction인터페이스가 정의되어 있고, 이 인터페이스를 구현한 익명 클래스를 생성했다.interface MyFunction {\tpublic abstract int max(int a, int b);}MyFunction f = new MyFunction() {\t\t\t\t\t\t\t\tpublic int max(int a, int b) {\t\t\t\t\t\t\t\t\treturn a &gt; b ? a : b;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t};int big = f.max(5, 3); // 익명 객체의 메서드를 호출위 코드의 익명 객체를 람다식으로 대체할 수 있다.Myfunction f = (int a, int b) -&gt; a &gt; b ? a : b; // 익명 객체를 람다식으로 대체int big = f.max(5, 3); // 익명 객체의 메서드를 호출이처럼 익명 객체를 람다식으로 대체가 가능한 이유는 람다식도 실제로는 익명 객체이기 때문이다.람다식을 다루기 위한 인터페이스를 함수형 인터페이스(functional interface)라고 부르기로 했다.함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다. 반면에 static메서드와 default메서드의 개수에는 제약이 없다.@FunctionalInterface를 붙이면 컴파일러가 함수형 인터페이스를 올바르게 정의했는지 알려준다.@FunctionalInterfaceinterface MyFunction {\tvoid myMethod(); // 추상 메서드\tvoid myMethod2(); // 에러! 추상메서드는 하나만 정의\tstatic void myMethod3(); // static 메서드\tdefault void myMethod3(); // default 메서드}@FunctionalInterfaceinterface MyFunction {\tvoid run(); // public abstract void run();}class LambdaEx1 {\tstatic void execute(MyFunction f) { // 매개변수 타입이 MyFunction인 메서드\t\tf.run();\t}\tstatic MyFunction getMyFunction() { // 반환 타입이 MyFunction인 메서드\t\tMyFunction f = () -&gt; System.out.println(\"f3.run()\");\t\treturn f;\t}\tpublic static void main(String[] args) {\t\t// 람다식으로 MyFunction의 run()을 구현\t\tMyFunction f1 = () -&gt; System.out.println(\"f1.run()\");\t\t// 익명클래스로 run()을 구현\t\tMyFunction f2 = new MyFunction() {\t\t\tpublic void run() { // public을 반드시 붙여야 함\t\t\t\tSystem.out.println(\"f2.run()\");\t\t\t}\t\t};\t\tMyFunction f3 = getMyFunction();\t\tf1.run();\t\tf2.run();\t\tf3.run();\t\texecute(f1);\t\texecute( () -&gt; System.out.println(\"run()\") );\t}}/*[실행결과]f1.run()f2.run()f3.run()f1.run()run()*/람다식의 타입과 형변환람다식은 익명 객체이고 익명 객체는 타입이 없다. 그래서 아래와 같이 형변환이 필요하다. (생략가능)람다식은 객체인데도 Object타입으로 형변환 할 수 없다. 오직 함수형 인터페이스로만 형변환이 가능하다.굳이 Object타입으로 형변환하려면, 먼저 함수형 인터페이스로 변환해야 한다.interface MyFunction {\tvoid method();}MyFunction f = (MyFunction)(()-&gt;{}); // 양변의 타입이 다르므로 형변환이 필요MyFunction f = (()-&gt;{}); // 이 형변환은 생략이 가능하다.Object obj = (Object)(()-&gt;{}); // 에러. 함수형 인터페이스로만 형변환 가능Object obj = (Object)(MyFunction)(()-&gt;{});String str = ((Object)(MyFunction)(()-&gt;{})).toString();외부 변수를 참조하는 람다식람다식도 익명 객체, 즉 익명 클래스의 인스턴스이므로 외부 변수를 참조하는 규칙은 익명 클래스와 동일하다.@FunctionalInterfaceinterface MyFunction {\tvoid myMethod();}class Outer {\tint val = 10; // Outer.this.val\tclass Inner {\t\tint val = 20; // this.val\t\tvoid method(int i) { // void method(final int i) {\t\t\tint val = 30; // final int val = 30;//\t\t\ti = 10; // 에러. 상수의 값을 변경할 수 없음.//\t\t\tMyFunction f = (i) -&gt; { // 에러. 외부 지역변수와 같은 이름의 람다식 매개변수는 허용 안됨.\t\t\tMyFunction f = () -&gt; {\t\t\t\tSystem.out.println(\" i : \" + i);\t\t\t\tSystem.out.println(\" val : \" + val);\t\t\t\tSystem.out.println(\" this.val : \" + ++this.val);\t\t\t\tSystem.out.println(\"Outer.this.val : \" + ++Outer.this.val);\t\t\t};\t\t\tf.myMethod();\t\t}\t}}class LambdaEx3 {\tpublic static void main(String[] args) {\t\tOuter outer = new Outer();\t\tOuter.Inner inner = outer.new Inner();\t\tinner.method(100);\t}}/*[실행결과] i : 100 val : 30 this.val : 21Outer.this.val : 11*/람다식 내에서 참조하는 지역변수는 final이 붙지 않았어도 상수로 간주된다. 위 예제에서 람다식 내에서 지역변수 i와 val를 참조하고 있으므로 상수로 간주된다.반면에 this.val과 Outer.this.val은 상수로 간주되지 않으므로 값을 변경해도 된다.그리고 외부 지역변수(i)와 같은 이름의 람다식 매개변수는 허용되지 않는다.java.util.function패키지대부분의 메서드 타입은 비슷하다. 매개변수가 없거나 한 개 또는 두 개, 반환 값은 없거나 한 개. 게다가 지네릭 메서드로 정의하면 매개변수나 반환 타입이 달라도 문제가 되지 않는다. 그래서 java.util.function패키지에 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해 놓았다.매번 새롭게 정의하지 말고 가능하면 이 패키지의 인터페이스를 활용하는 것이 좋다.그래야 메서드 이름도 통일되고, 재사용성이나 유지보수 측면에서도 좋다.기본적인 함수형 인터페이스 함수형 인터페이스 메서드 설명 java.lang.Runnable void run() 매개변수도 없고, 반환값도 없음. Supplier T get() 매개변수는 없고, 반환값만 있음. Consumer void accept(T t) 매개변수만 있고, 반환값이 없음. Function&lt;T, R&gt; R apply(T t) 일반적인 함수. 하나의 매개변수를 받아서 하나의 결과를 반환 Predicate boolean test(T t) 조건식을 표현하는데 사용됨. 매개변수는 하나, 반환 타입은 boolean 타입 문자 T는 Type을 R은 Return Type을 의미한다.매개변수가 두 개인 함수형 인터페이스 함수형 인터페이스 메서드 설명 BiConsumer&lt;T, U&gt; void accept(T t, U u) 두개의 매개변수만 있고, 반환값이 없음 BiFunction&lt;T, U, R) R apply(T t, U u) 두 개의 매개변수를 받아서 하나의 결과를 반환 BiPredicate&lt;T, U&gt; boolean test(T t, U u) 조건식을 표현하는데 사용됨. 매개변수는 둘. 반환 타입은 boolean 두 개 이상의 매개변수를 갖는 함수형 인터페이스가 필요하다면 직접 만들어서 써야한다.UnaryOperator와 BinaryOperatorFunction의 또 다른 변형으로 매개변수 타입과 반환 타입이 모두 일치한다. 함수형 인터페이스 메서드 설명 UnaryOperator T apply(T t) Function의 자손. Function과 달리 매개변수와 결과의 타입이 같아. BinaryOperator T apply(T t, T t) BiFunction의 자손. BiFunction과 달리 매개변수와 결과의 타입이 같다. 컬렉션 프레임웍과 함수형 인터페이스컬렉션 프레임웍의 인터페이스에 다수의 디폴트 메서드가 추가되었는데, 그 중의 일부는 함수형 인터페이스를 사용한다. 인터페이스 메서드 설명 Collection boolean removeIf(Predicate filter) 조건에 맞는 요소를 삭제 List void replaceAll(UnaryOperator operator) 모든 요소를 변환하여 대체 Iterable void forEach(Consumer action) 모든 요소에 작업 action을 수행 Map V compute(K key, BiFunction&lt;K, V, V&gt; f) 지정된 키의 값에 작업 f를 수행   V computeIfAbsent(K key, Function&lt;K, V&gt; f) 키가 없으면, 작업 f 수행 후 추가   V computeIfPresent(K key, BiFunction&lt;K, V, V&gt; f) 지정된 키가 있을 때, 작업 f 수행   V merge(K key, V value, BiFunction&lt;V, V, V&gt; f) 모든 요소에 병합작업 f를 수행   void forEach(BiConsumer&lt;K, V&gt; action) 모든 요소에 작업 action을 수행   void replaceAll(BiFunction&lt;K, V, V&gt; f) 모든 요소에 치환작업 f를 수행 위에 메서드들을 어떤 식으로 사용하는지 다음의 예제를 보면 알 수 있다.import java.util.*;class LambdaEx4 {\tpublic static void main(String[] args) {\t\tArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\t\tfor(int i = 0; i &lt; 10; i++)\t\t\tlist.add(i);\t\t// list의 모든 요소를 출력\t\tlist.forEach(i -&gt; System.out.print(i + \",\"));\t\tSystem.out.println();\t\t// list에서 2 또는 3의 배수를 제거한다.\t\tlist.removeIf(x -&gt; x % 2 == 0 || x % 3 == 0);\t\tSystem.out.println(list);\t\t// list의 각 요소에 10을 곱한다.\t\tlist.replaceAll(i -&gt; i * 10);\t\tSystem.out.println(list);\t\tMap&lt;String, String&gt; map = new HashMap&lt;&gt;();\t\tmap.put(\"1\", \"1\");\t\tmap.put(\"2\", \"2\");\t\tmap.put(\"3\", \"3\");\t\tmap.put(\"4\", \"4\");\t\t// map의 모든 요소를 {k, v}의 형식으로 출력한다.\t\tmap.forEach((k, v) -&gt; System.out.print(\"{\" + k + \", \" + v + \"}, \"));\t\tSystem.out.println();\t}}/*[실행결과]0,1,2,3,4,5,6,7,8,9,[1, 5, 7][10, 50, 70]{1, 1}, {2, 2}, {3, 3}, {4, 4},*/아래 예제는 앞서 공부한 함수형 인터페이스들을 사용하는 예제이다.import java.util.function.*;import java.util.*;class LambdaEx5 {\tpublic static void main(String[] args) {\t\tSupplier&lt;Integer&gt; s = () -&gt; (int)(Math.random() * 100) + 1;\t\tComsumer&lt;Integer&gt; c = i -&gt; System.out.print(i + \", \");\t\tPredicate&lt;Integer&gt; p = i -&gt; i % 2 == 0;\t\tFunction&lt;Integer, Integer&gt; f = i -&gt; i / 10 * 10; // i의 일의 자리를 없앤다.\t\tList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\t\tmakeRandomList(s, list);\t\tSystem.out.println(list);\t\tprintEvenNum(p, c, list);\t\tList&lt;Integer&gt; newList = doSomething(f, list);\t\tSystem.out.println(newList);\t}\tstatic &lt;T&gt; List&lt;T&gt; doSomething(Function&lt;T, T&gt; f, List&lt;T&gt; list) {\t\tList&lt;T&gt; newList = new ArrayList&lt;T&gt;(list.size());\t\tfor(T i : list) {\t\t\tnewList.add(f.apply(i));\t\t}\t\treturn newList;\t}\tstatic &lt;T&gt; void printEvenNum(Predicate&lt;T&gt; p, Consumer&lt;T&gt; c, List&lt;T&gt; list) {\t\tSystem.out.print(\"[\");\t\tfor(T i : list) {\t\t\tif(p.test(i))\t\t\t\tc.accept(i);\t\t}\t\tSystem.out.println(\"]\");\t}\tstatic &lt;T&gt; void makeRandomList(Supplier&lt;T&gt; s, List&lt;T&gt; list) {\t\tfor(int i = 0; i &lt; 10; i++) {\t\t\tlist.add(s.get());\t\t}\t}}/*[실행결과][20, 69, 25, 80, 16, 45, 46, 3, 3, 75][20, 80, 16, 46, ][20, 60, 20, 80, 10, 40, 40, 0, 0, 70]*/기본형을 사용하는 함수형 인터페이스오토박싱&amp;언방식으로 인해 기본형 타입 대신 래퍼(wrapper)클래스를 사용하는 것이 비효율적이기 때문에 아래 함수형 인터페이스가 제공된다. 함수형 인터페이스 메서드 설명 DoubleToIntFunction int applyAsInt(double d) AToBFunction은 입력 A타입, 출력 B타입 ToIntFunction int applyAsInt(T value) ToBFunction은 입력 지네릭타입, 출력 B타입 IntFunction R apply(int value) AFunction은 입력 A타입, 출력 지네릭타입 ObjIntConsumer void accept(T t, int i) ObjAFunction은 입력 T, A타입, 출력 없음 Function대신 IntFunction을 사용할 수도 있지만 IntUnaryOperator가 Function이나 IntFunction보다 오토방식&amp;언박싱의 횟수가 즐어들어 더 성능이 좋다.Function의 합성과 Predicate의 결합java.util.function패키지의 함수형 인터페이스에는 추상메서드 외에도 디폴트메서드와 static메서드가 정의되어 있다.Function의 합성수학에서 두 함수를 합성해서 하나의 새로운 함수를 만들어낼 수 있다는 것처럼, 두 람다식을 합성해서 새로운 람다식을 만들 수 있다.두 함수의 합성은 어느 함수를 먼저 적용하느냐에 따라 달라진다. 함수 f, g가 있을 떄, f.andThen(g)는 함수 f를 먼저 적용하고, 그 다음에 함수 g를 적용한다. 그리고 f.compose(g)는 반대로 g를 먼저 적용하고 f를 적용한다.문자열을 숫자로 변환하는 함수 f와 숫자를 2진 문자열로 변환하는 함수 g를 andThen()으로 합성하여 새로운 함수 h를 만들어낼 수 있다.Function&lt;String, Integer&gt; f = (s) -&gt; Integer.parseInt(s. 16); // s를 16진수로 인식Function&lt;Integer, String&gt; g = (i) -&gt; Integer.toBinaryString(i);Function&lt;String, String&gt; h = f.andThen(g);System.out.println(h.apply(\"FF\")); // \"FF\" -&gt; 255 -&gt; \"11111111\"이번엔 compose()를 이용해서 반대의 순서로 합성해보자.Function&lt;Integer, String&gt; g = (i) -&gt; Integer.toBinaryString(i); // i를 2진 문자열로 변환Function&lt;String, Integer&gt; f = (s) -&gt; Integer.parseInt(s. 16); // s를 16진수로 인식해서 변환Function&lt;Integer, Integer&gt; h = f.compose(g);System.out.println(h.apply(2)); // 2 -&gt; \"10\" -&gt; 16그리고 identity()는 항등 함수가 필요할 때 사용한다. 이 함수를 람다식으로 표현하면 x -&gt; x이다.Function&lt;String, String&gt; f = x -&gt; x;// Funciont&lt;String, String&gt; f = Function.identity(); // 위의 문장과 동일System.out.println(f.apply(\"AAA\")); // AAA가 그대로 출력됨항등 함수는 잘 사용되지 않는 편이며, 변환없이 그대로 처리하고자할 때 사용된다.Predicate의 결합 여러 조건식을 논리 연산자인 &amp;&amp;(and),   (or), !(not)으로 연결해서 하나의 식을 구성할 수 있는 것처럼, 여러 Predicate를 and(), or(), negate()로 연결해서 하나의 새로운 Predicate로 결합할 수 있다. Predicate&lt;Integer&gt; p = i -&gt; i &lt; 100;Predicate&lt;Integer&gt; q = i -&gt; i &lt; 200;Predicate&lt;Integer&gt; r = i -&gt; i % 2 == 0;Predicate&lt;Integer&gt; notP = p.negate(); // i &gt;= 100Predicate&lt;Integer&gt; all = notP.and(q).or(r); // 100 &lt;= i &amp;&amp; i &lt; 200 || i % 2 == 0System.out.println(all.test(150)); // true이처럼 and(), or(), negate()로 여러 조건식을 하나로 합칠 수 있다. 람다식을 직접 넣어도 된다.그리고 static메서드인 isEqual()은 두 대상을 비교하는 Predicate를 만들 때 사용한다.Predicate&lt;String&gt; p = Predicate.isEqual(str1);boolean result = p.test(str2); // str1과 str2가 같은지 비교하여 결과를 반환// 위의 두 문장을 합치면boolean result = Predicate.isEqual(str1).test(str2) // str1과 str2가 같은지 비교메서드 참조람다식이 하나의 메서드만 호출하느 경우에는 메서드 참조(method reference)라는 방법으로 람다식을 간략히 할 수 있다.예를 들어 문자열을 정수로 변환하는 람다식은 아래와 같이 작성할 수 있다.Function&lt;String, Integer&gt; f = (String s) -&gt; Integer.parseInt(s); // 람다식Function&lt;String, Integer&gt; f2 = Integer::parseInt; // 메서드 참조BiFunction&lt;String, String, Boolean&gt; f = (s1, s2) -&gt; s1.equals(s2); // 람다식BiFunction&lt;String, String, Boolean&gt; f2 = String::equals; // 메서드 참조MyClass obj = new MyClass();Function&lt;String, Boolean&gt; f = (x) -&gt; obj.equals(x); // 람다식Function&lt;String, Boolean&gt; f2 = obj::equals; // 메서드 참조위에 3가지 경우의 메서드 참조를 정리하면 다음과 같다. 종류 람다 메서드 참조 static메서드 참조 (x) -&gt; ClassName.method(x) ClassName::method 인스턴스메서드 참조 (obj, x) -&gt; obj.method(x) ClassName::method 특정 객체 인스턴스메서드 참조 (x) -&gt; obj.method(x) obj::method 하나의 메서드만 호출하는 람다식은 클래스이름::메서드이름 또는 참조변수::메서드이름으로 바꿀 수 있다.생성자의 메서드 참조생성자를 호출하는 람다식도 메서드 참조로 변환할 수 있다.Supplier&lt;MyClass&gt; s = () -&gt; new MyClass(); // 람다식Supplier&lt;MyClass&gt; s2 = MyClass::new; // 메서드 참조매개변수가 있는 생성자라면, 매개변수의 개수에 따라 알맞은 함수형 인터페이스를 사용하면 된다.Function&lt;Integer, MyClass&gt; f = (i) -&gt; new MyClass(i); // 람다식Function&lt;Integer, MyClass&gt; f2 = MyClass::new; // 메서드 참조BiFunction&lt;Integer, String, MyClass&gt; bf = (i, s) -&gt; new MyClass(i, s) // 람다식BiFunction&lt;Integer, String, MyClass&gt; bf = MyClass::new // 메서드 참조배열을 생성할 때는 아래와 같이 하면 된다.Function&lt;Integer, int[]&gt; f = x -&gt; new int[x]; // 람다식Function&lt;Integer, int[]&gt; f2 = int[]:new; // 메서드 참조메서드 참조는 람다식을 마치 static변수처럼 다룰 수 있게 해준다.출처자바의 정석" }, { "title": "내부 클래스(inner class)", "url": "/posts/inner-class/", "categories": "Java", "tags": "Java, 내부 클래스, inner class", "date": "2022-10-27 00:00:00 +0900", "snippet": "내부 클래스란?내부 클래스는 클래스 내에 선언된 클래스이다. 클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다.class A { // 외부 클래스\t// ...\tclass B { // 내부 클래스\t\t// ...\t}\t// ...}내부클래스의 장점 내부 클래스에서 외부클래스의 맴버들을 쉽게 접근할 수 있다. 코드의 복잡성을 줄일 수 있다.(캡슐화)내부 클래스의 종류와 특징내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다. 내부 클래스 특징 인스턴스 클래스(instance class) 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언한다. 스태틱 클래스(static class) 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. 주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언한다. 지역 클래스(local class) 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다. 익명 클래스(anonymous class) 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용) 내부 클래스의 선언변수가 선언된 위치에 따라 인스턴스변수, 클래스변수(static변수), 지역변수로 나뉘듯이 내부 클래스도 이와 마찬가지로 선언된 위치에 따라 나뉘고 각 내부 클래스의 선언위치에 따라 같은 선언위치에 변수와 동일한 유효범위(scope)와 접근성(accessibility)을 갖는다.class Outer {\tint iv = 0;\tstatic int cv = 0;\tvoid myMethod() {\t\tint lv = 0;\t}}class Outer {\tclass InstanceInner { }\tstatic class StaticInner { }\tvoid myMethod() {\t\tclass LocalInner { }\t}}내부 클래스의 제어자와 접근성내부 클래스도 클래스이기 때문에 abstract나 final과 같은 제어자를 사용할 수 있을 뿐만 아니라, 멤버변수들처럼 private, protected과 같은 접근제어자도 사용이 가능하다.static클래스만 static멤버를 가질 수 있다. 다만, final과 static이 동시에 붙은 변수는 상수이므로 모든 내부 클래스에서 정의가 가능하다.인스턴스클래스는 스태틱 클래스의 멤버들을 객체생성 없이 사용할 수 있지만, 스태틱 클래스는 인스턴스클래스의 멤버들을 객체생성 없이 사용할 수 없다.아래는 내부 클래스에서 외부 클래스의 변수들에 대한 접근성을 보여주는 예제이다.class InnerEx3 {\tprivate int outerIv = 0;\tstatic int outerCv = 0;\tclass InstanceInner {\t\tint iiv = outerIv; // 외부 클래스의 private멤버도 접근가능하다.\t\tint iiv2 = outerCv;\t}\tstatic class StaticInner {\t\t// 스태틱 클래스는 외부 클래스의 인스턴스멤버에 접근 할 수 없다.\t\t// int siv = outerIv; // 에러\t\tstatic int scv = outerCv;\t}\tvoid myMethod() {\t\tint iv = 0;\t\tfinal int LV = 0; // JDK1.8부터 final 생략 가능\t\tclass LocalInner {\t\t\tint liv = outerIv;\t\t\tint liv2 = outerCv;\t\t\t// 외부 클래스의 지역변수는 final이 붙은 변수(상수)만 접근가능하다.\t\t\t// int liv3 = lv; // 에러!!!(JDK1.8부터 에러 아님)\t\t\tint liv4 = LV; // OK\t\t}\t}}컴파일 했을 때 생성되는 파일명은 ‘외부 클래스명$내부 클래스명.class’형식으로 되어 있다.class Outer {\tint value = 10; // Outer.this.value\tclass Inner {\t\tint value = 20; // this.value\t\tvoid method1() {\t\t\tint value = 30;\t\t\tSystem.out.println(\" value : \" + value);\t\t\tSystem.out.println(\" this.value : \" + this.value);\t\t\tSystem.out.println(\"Outer.this.value : \" + Outer.this.value);\t\t}\t}}class InnerEx5 {\tpublic static void main(String[] args) {\t\tOuter outer = new Outer();\t\touter.Inner inner = outer.new Inner();\t\tinner.method1();\t}}/*[실행결과] value : 30 this.value : 20Outer.this.value : 10*/내부 클래스와 외부 클래스에 선언된 변수의 이름이 같을 때 변수 앞에 this 또는 외부클래스명.this를 붙여서 서로 구별할 수 있다.익명 클래스(anonymous class)이름이 없고 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.new 조상클래스이름() {\t// 멤버 선언}또는new 구현인터페이스이름() {\t// 멤버 선언}이름이 없기 때문에 생성자도 가질 수 없으며, 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.class InnerEx6 {\tObject iv = new Object() { void method() { } }; // 익명클래스\tstatic Object cv = new Object() { void method() { } }; // 익명클래스\tvoid myMethod() {\t\tObject lv = new Object() { void method() { } }; // 익명클래스\t}}아래 예제를 실행하면 아무것도 나타나지 않는다. 단지 익명클래스로 변환하는 예를 보여주기 위한 예제다.import java.awt.*;import java.awt.event.*;class InnerEx7 {\tpublic static void main(String[] args) {\t\tButton b = new Button(\"Start\");\t\tb.addActionListener(new EventHandler());\t}}class EventHandler implements ActionListener {\tpublic void actionPerformed(ActionEvenet e) {\t\tSystem.out.println(\"ActionEvent occurred!!!\");\t}}class InnerEx8 {\tpublic static void main(String[] args) {\t\tButton b = new Button(\"Start\");\t\tb.addActionListener(new ActionListener() {\t\t\tpublic void actionPerformed(ActionEvenet e) {\t\t\t\tSystem.out.println(\"ActionEvent occurred!!!\");\t\t\t}\t\t}); // 익명클래스 끝\t} // main 끝}InnerEx7, EventHandler를 익명클래스를 이용해서 변경한 것이 InnerEx8이다. 먼저 두 개의 독립된 클래스를 작성한 다음에, 다시 익명클래스를 이용하여 변경하면 보다 쉽게 코드를 작성할 수 있다.출처자바의 정석" }, { "title": "인터페이스(interface)", "url": "/posts/interface/", "categories": "Java", "tags": "Java, 인터페이스, interface", "date": "2022-10-26 00:00:00 +0900", "snippet": "인터페이스란?인터페이스는 일종의 추상클래스이지만 일반메서드 또는 맴버변수를 가질 수 없고, 오직 추상메서드와 상수만을 맴버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다.추상클래스를 미완성 설계도라고 한다면, 인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져있는 기본 설계도라 할 수 있다.인터페이스의 작성클래스를 작성하는 것과 같다. 다만 키워드로 class 대신 interface를 사용한다. 그리고 접근제어자로 public 또는 default를 사용할 수 있다.interface 인터페이스이름 {\tpublic static final 타입 상수이름 = 값;\tpublic abstract 메서드이름(매개변수목록);}인터페이스 맴버들의 제약사항 모든 맴버변수는 public static final 이어야 하며, 이를 생략할 수 있다. 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다. 단, static메서드와 default메서드는 예외(JDK1.8부터 변경) 생략된 제어자는 컴파일 시에 컴파일러가 자동적으로 추가해준다.interface PlayingCard {\tpublic static final int SPADE = 4;\tfinal int DIAMOND = 3; // public static final int DIAMOND = 3;\tstatic int HEART = 2; // public static final int HEART = 2;\tint CLOVER = 1; // public static final int CLOVER = 1;\tpublic abstract String getCardNumber();\tString getCardKind(); // public abstract String getCardKind();}원래는 인터페이스의 모든 메서드는 추상메서드이어야 하는데, JDK1.8부터 인터페이스에 static메서드와 default메서드의 추가를 허용하는 방향으로 변경되었다.인터페이스의 상속인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중상속이 가능하다.interface Movable {\t/* 지정된 위치로 이동하는 기능의 메서드 */\tvoid move(int x, int y);}interface Attackable {\t/* 지정된 대상을 공격하는 기능의 메서드 */\tvoid attack(Unit u);}interface Fightable extends Movable, Attackable { }인터페이스의 구현인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼, 인터페이스도 다르지 않다. 다만 클래스는 확장한다는 의미로 extends를 사용하지만 인터페이스는 구현한다는 의미로 implements를 사용한다.class 클래스이름 implements 인터페이스이름 {\t// 인터페이스에 정의된 추상메서드를 구현해야 한다.}class Fighter implements Fightable {\tpublic void move(int x, int y) { /* 내용 생략 */ }\tpublic void attack(Unit) { /* 내용 생략 */ }}만일 인터페이스의 메서드 중 일부만 구현한다면, 추상클래스로 선언해야 한다.abstract class Fighter implements Fightable {\tpublic void move(int x, int y) { /* 내용 생략 */ }}그리고 다음과 같이 상속과 구현을 동시에 할 수도 있다.class Fighter extends Unit implements Fightable {\tpublic void move(int x, int y) { /* 내용 생략 */ }\tpublic void attack(Unit) { /* 내용 생략 */ }}인터페이스를 이용한 다중상속두 조상으로부터 상속받은 맴버 중에서 맴버변수의 이름이 같거나 메서드의 선언부가 일치하고 구현 내용이 다르다면 이 두 조상으로부터 상속받는 자손클래스는 어느 조상의 것을 상속받게 되는 것인지 알 수 없다.그래서 다중상속은 장점도 있지만 단점이 더 크다고 판단하였기 때문에 자바에서는 다중상속을 허용하지 않는다. 그러나 또 다른 객체지향언어인 C++에서는 다중상속을 허용하기 때문에 자바는 다중상속을 허용하지 않는다는 것이 단점으로 부각되는 것에 대한 대응으로 자바도 인터페이스를 이용하면 다중상속이 가능하다라고 하는 것일 뿐 자바에서 인터페이스로 다중상속을 구현하는 경우는 거의 없다.인터페이스는 static상수만 정의할 수 있으므로 조상클래스의 맴버변수와 충돌하는 경우는 거의 없고 충돌된다 하더라도 클래스 이름을 붙여서 구분이 가능하다. 그리고 추상메서드는 구현내용이 전혀 없으므로 조상클래스의 메서드와 선언부가 일치하는 경우에는 당연히 조상클래스 쪽의 메서드를 상속받으면 되므로 문제가되지 않는다.그러나, 이렇게 하면 상속받는 맴버의 충돌은 피할 수 있지만, 다중상속의 장점을 잃게된다. 만일 두 개의 클래스로부터 상속을 받아야 할 상황이라면, 두 조상클래스 중에서 비중이 높은 쪽을 선택하고 다른 한쪽은 클래스 내부에 맴버로 포함시키는 방식으로 처리하거나 어느 한쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현하도록 한다.예를 들어, Tv클래스와 VCR클래스가 있을 때, TVCR클래스를 작성하기 위해 한 쪽만 선택하여 상속받고 나머지 한 쪽은 클래스 내부에 포함시켜서 내부적으로 인스턴스를 생성해서 사용한다.public class Tv {\tprotected boolean power;\tprotected int channel;\tprotected int volume;\tpublic void power() { power = !power; }\tpublic void channelUp() { channel++; }\tpublic void channelDown() { channel--; }\tpublic void volumeUp() { volume++; }\tpublic void volumeDown() { volume--; }}public class VCR {\tprotected int counter; // VCR의 카운터\tpublic void play() {\t\t// Tape을 재생한다.\t}\tpublic void stop() {\t\t// 재생을 멈춘다.\t}\tpublic void reset() {\t\tcounter = 0;\t}\tpublic int getCounter() {\t\treturn counter;\t}\tpublic void setCounter(int c) {\t\tcounter = c;\t}}VCR클래스에 정의된 메서드와 동일하게 추상메서드를 갖는 인터페이스를 작성한다.public interface IVCR {\tpublic void play();\tpublic void stop();\tpublic void reset();\tpublic int getCounter();\tpublic void setCounter(int c);}IVCR 인터페이스를 구현하고 Tv클래스로부터 상속받는 TVCR클래스를 작성한다.이때 VCR클래스 타입의 참조변수를 맴버변수로 선언하여 IVCR인터페이스의 추상메서드를 구현하는데 사용한다.public class TVCR extends Tv implements IVCR {\tVCR vcr = new VCR();\tpublic void play() {\t\tvcr.play(); // 코드를 작성하는 대신 VCR인스턴스의 메서드를 호출한다.\t}\tpublic void stop() {\t\tvcr.stop();\t}\tpublic void reset() {\t\tvcr.reset();\t}\tpublic int getCounter() {\t\tvcr.getCounter()\t}\tpublic void setCounter(int c) {\t\tvcr.setCounter(c);\t}}IVCR인터페이스를 구현하기 위해서는 새로 메서드를 작성해야하는 부담이 있지만 이처럼 VCR클래스의 인스턴스를 사용하면 손쉽게 다중상속을 구현할 수 있다.인터페이스를 이용한 다형성다형성에 대해 학습할 때 자손클래스의 인스턴스를 조상타입의 참조변수로 참조하는 것이 가능하다는 것을 배웠다. 인터페이스 역시 가능하다.인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter인스턴스를 Fightable타입의 참조변수로 참조하는 것이 가능하다.Fightable f = (Fightable)new Fighter();또는Fightable f = new Fighter();interface Parseable {\t// 구문 분석작업을 수행한다.\tpublic abstract void parse(String fileName);}class ParserManager {\t// 리턴타입이 Parseable인터페이스이다.\tpublic static Parseable getParser(String type) {\t\tif(type.equals(\"XML\")) {\t\t\treturn new XMLParser();\t\t} else {\t\t\treturn new HTMLParser();\t\t}\t}}class XMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \" - XML parsing completed.\");\t}}class HTMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \" - HTML parsing completed.\");\t}}class ParserTest {\tpublic static void main(String[] args) {\t\tParseable parser = ParserManage.getParser(\"XML\");\t\tparser.parse(\"document.xml\");\t\tParseable parser = ParserManage.getParser(\"HTML\");\t\tparser.parse(\"document2.xml\");\t}}/*[실행결과]document.xml - XML parsing completed.document2.xml - HTML parsing completed.*/ParserManager클래스의 getParser메서드는 매개변수로 넘겨받은 type의 값에 따라 XMLParser인스턴스 또는 HTMLParser인스턴스를 반환한다.만일 나중에 새로운 종류의 XML구문분석기 NewXMLParser클래스가 나와도 ParserTest클래스는 변경할 필요 없이 ParserManager클래스의 getParser메서드에서 return new XMLParser(); 대신 return new NewXMLParser();로 변경하기만 하면 된다.이러한 장점은 특히 분산환경 프로그래밍에서 그 위력을 발휘한다. 사용자 컴퓨터에 설치된 프로그램을 변경하지 않고 서버측의 변경만으로도 사용자가 새로 개정된 프로그램을 사용하는 것이 가능하다.인터페이스의 장점 개발시간을 단축시킬 수 있다. 일단 인터페이스가 작성되면 이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문이다. 그리고 동시에 다른 한 쪽에서는 인터페이스를 구현하는 클래스를 작성하도록 하여, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다. 표준화가 가능하다. 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다. 서로 관계없는 클래스에게 관계를 맺어 줄 수 있다. 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다. 독립적인 프로그래밍이 가능하다. 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다. 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다. class RepairableTest {\tpublic static void main(String[] args) {\t\tTank tank = new Tank();\t\tDropship dropship = new Dropship();\t\tMarine marine = new Marine();\t\tSCV scv = new SCV();\t\tscv.repair(tank); // SCD가 Tank를 수리하도록 한다.\t\tscv.repair(dropship);//\t\tscv.repair(marine); // 에러!\t}}interface Repairable { }class GroundUnit extends Unit {\tGroundUnit(int hp) {\t\tsuper(hp);\t}}class AirUnit extends Unit {\tAirUnit(int hp) {\t\tsuper(hp);\t}}class Unit {\tint hitPoint;\tfinal int MAX_HP;\tUnit(int hp) {\t\tMAX_HP = hp;\t}\t// ...}class Tank extends GroundUnit implements Repairable {\tTank() {\t\tsuper(150); // Tank의 HP는 150이다.\t\thitPoint = MAX_HP;\t}\tpublic String toString() {\t\treturn \"Tank\";\t}\t// ...}class Dropship extends AirUnit implements Repairable {\tDropship() {\t\tsuper(125); // Dropship의 HP는 125이다.\t\thitPoint = MAX_HP;\t}\tpublic String toString() {\t\treturn \"Dropship\";\t}\t// ...}class Marine extends GroundUnit {\tMarine() {\t\tsuper(40);\t\thitPoint = MAX_HP;\t}\t// ...}class SCV extends implements Repairable {\tSCV() {\t\tsuper(60);\t\thitPoint = MAX_HP;\t}\tvoid repair(Repairable r) {\t\tif(r instanceof Unit) {\t\t\tUnit u = (Unit)r;\t\t\twhile(u.hitPoint != u.MAX_HP) {\t\t\t\t/* Unit의 HP를 증가시킨다. */\t\t\t\tu.hitPoint++;\t\t\t}\t\t\tSystem.out.println(u.toString() + \"의 수리가 끝났습니다.\");\t\t}\t}\t// ...}/*[실행결과]Tank의 수리가 끝났습니다.Dropship의 수리가 끝났습니다.*/인터페이스의 이해 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다. 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.(내용은 몰라도 된다.)class A {\tpublic void methodA(B b) {\t\tb.methodB();\t}}class B {\tpublic void methodB() {\t\tSystem.out.println(\"methodB()\");\t}}class InterfaceTest {\tpublic static void main(String[] args) {\t\tA a = new A();\t\ta.methodA(new B());\t}}/*[실행결과]methodB()*/위와 같이 클래스 A(User)는 클래스B(Provider)의 인스턴스를 생성하고 메서드를 호출한다. 이 두 클래스는 서로 직접적인 관계가 있다.이와 같이 직접적인 관계의 두 클래스는 한 쪽(Provider)이 변경되면 다른 한 쪽(User)도 변경되어야 한다는 단점이 있다.그러나 인터페이스를 매개체로 해서 메서드에 접근하도록 하면, 클래스 B에 변경사항이 생겨도 클래스 A는 전혀 영향을 받지 않도록 하는 것이 가능하다.class A {\tvoid autoPlay(I i) {\t\ti.play();\t}}interface I {\tpublic abstract void play();}class B implements I {\tpublic void play() {\t\tSystem.out.println(\"play in B class\");\t}}class C implements I {\tpublic void play() {\t\tSystem.out.println(\"play in C class\");\t}}class InterfaceTest2 {\tpublic static void main(String[] args) {\t\tA a = new A();\t\ta.autoPlay(new B()); // void autoPlay(I i) 호출\t\ta.autoPlay(new C()); // void autoPlay(I i) 호출\t}}/*[실행결과]play in B classplay in C class*/위와 같이 클래스 A를 작성하는데 클래스 B가 관련되지 않았다는 사실에 주목하자.Thread의 생성자인 Thread(Runnable target)이 이런 방식으로 되어 있다.이처럼 매개변수를 통해 동적으로 제공받을 수 도 있지만 다음과 같이 제 3의 클래스를 통해서 제공받을 수도 있다. JDBC의 DriverManager클래스가 이런 방식으로 되어 있다.class InterfaceTest3 {\tpublic static void main(String[] args) {\t\tA a = new A();\t\ta.methodA();\t}}class A {\tvoid methodA() {\t\tI i = InstanceManager.getInstance(); // 제 3의 클래스의 메서드를 통해서 인터페이스 I를 구현한 클래스의 인스턴스를 얻어온다.\t\ti.methodB();\t\tSystem.out.println(i.toString()); // i로 Object클래스의 메서드 호출가능\t}}interface I {\tpublic abstract void methodB();}class B implements I {\tpublic void methodB() {\t\tSystem.out.println(\"methodB in B class\");\t}\tpublic String toString() { return \"class B\"; }}class InstanceManager {\tpublic static I getInstance() {\t\treturn new B();\t}}/*[실행결과]methodB in B classclass B*/인스턴스를 직접 생성하지 않고, getInstance()라는 메서드를 통해 제공받는다. 이렇게 하면, 나중에 다른 클래스의 인스턴스로 변경되어도 A클래스의 변경없이 getInstance()만 변경하면 된다는 장점이 생긴다.디폴트 메서드와 static메서드원래는 인터페이스에 추상메서드만 선언할 수 있는데, JDK1.8부터 디폴트메서드와 static메서드도 추가할 수 있게 되었다.static메서드는 인스턴스와 관계가 없는 독립적인 메서드이기 때문에 추가하지 못할 이유가 없었지만 자바를 보다 쉽게 배울 수 있도록 규칙을 단순히 할 필요가 있었다. 접근 제어자가 항상 public이며, 생략할 수 있다.조상클래스에 새로운 메서드를 추가하는 것은 별 일이 아니지만, 인터페이스의 경우에는 이 인터페이스를 구현한 기존의 모든 클래스들이 새로 추가된 메서드를 구현해야 하기 때문에 디폴트메서드를 고안해 내었다.디폴트메서드는 추상메서드의 기본적인 구현을 제공하는 메서드로, 추상메서드가 아니기 때문에 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다. 그리고 메서드 앞에 default를 붙이며 몸통{}이 있어야 한다. 접근제어자가 public이며, 생략할 수 있다.새로 추가된 디폴트메서드가 기존의 메서드와 이름이 중복되어 충돌하는 경우가 발생한다. 이 충돌을 해결하는 규칙은 다음과 같다. 여러 인터페이스의 디폴트메서드 간의 충돌 인터페이스를 구현한 클래스에서 디폴트메서드를 오버라이딩해야한다. 디폴트 메서드와 조상클래스의 메서드 간의 충돌 조상클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다. class DefaultMethodTest {\tpublic static void main(String[] args) {\t\tChild c = new Child();\t\tc.method1();\t\tc.method2();\t\tMyInterface.staticMethod();\t\tMyInterface2.staticMethod();\t}}class Child extends Parent implements MyInterface, MyInterface2 {\tpublic void method1() {\t\tSystem.out.println(\"method1() in Child\"); // 오버라이딩\t}}class Parent {\tpublic void method2() {\t\tSystem.out.println(\"method2() in Parent\");\t}}interface MyInterface {\tdefault void method1() {\t\tSystem.out.println(\"method1() in MyInterface\");\t}\tdefault void method2() {\t\tSystem.out.println(\"method2() in MyInterface\");\t}\tstatic void staticMethod() {\t\tSystem.out.println(\"staticMethod() in MyInterface\");\t}}interface MyInterface2 {\tdefault void method1() {\t\tSystem.out.println(\"method1() in MyInterface2\");\t}\tstatic void staticMethod() {\t\tSystem.out.println(\"staticMethod() in MyInterface2\");\t}}/*[실행결과]method1() in Childmethod2() in ParentstaticMethod() in MyInterfacestaticMethod() in MyInterface2*/출처자바의 정석" }, { "title": "추상클래스(abstract class)", "url": "/posts/abstract-class/", "categories": "Java", "tags": "Java, 추상클래스, abstract class", "date": "2022-10-21 00:00:00 +0900", "snippet": "추상클래스란?클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다.클래스가 미완성이라는 것은 맴버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다.미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.추상클래스는 키워드 abstract를 붙이기만 하면 된다.abstract class 클래스이름 {\t// ...}추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고는 일반클래스와 전혀 다르지 않다. 추상클래스에도 생성자가 있으며, 맴버변수와 메서드도 가질 수 있다.추상메서드(abstract method)메서드의 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다. 즉, 설계만 해 놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.추상메서드 역시 키워드 abstract를 앞에 붙여 주고, 추상메서드는 구현부가 없으므로 괄호{}대신 문장의 끝을 알리는 ;를 적어준다./* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */abstract 리턴타입 메서드이름();추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다. 만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해 주어야 한다.abstract class Player { // 추상클래스\tabstract void play(int pos); // 추상메서드\tabstract void stop(); // 추상메서드}class AudioPlayer extends Player {\tvoid play(int pos) { /* 내용 생략 */ } // 추상메서드를 구현\tvoid stop() { /* 내용 생략 */ } // 추상메서드를 구현}abstract class AbstractPlayer extends Player {\tvoid play(int pos) { /* 내용 생략 */ } // 추상메서드를 구현}추상클래스의 작성추상화는 기존의 클래스의 공통부분을 뽑아내서 조상클래스를 만드는 것이라고 할 수 있다.추상화 - 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업구체화 - 상속을 통해 클래스를 구현, 확장하는 작업class Marine { // 보병\tint x, y; // 현재 위치\tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }\tvoid stop() { /* 현재 위치에 정지 */ }\tvoid stimPack() { /* 스팀팩을 사용한다. */ }}class Tank { // 탱크\tint x, y; // 현재 위치\tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }\tvoid stop() { /* 현재 위치에 정지 */ }\tvoid changeMode() { /* 공격모드로 변환한다. */ }}class Dropship { // 수송선\tint x, y; // 현재 위치\tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }\tvoid stop() { /* 현재 위치에 정지 */ }\tvoid load() { /* 선택된 대상을 태운다. */ }\tvoid unload() { /* 선택된 대상을 내린다. */ }}위에 클래스로부터 공통된 부분을 뽑아내어 추상클래스를 만들어보면 아래와 같다.abstract class Unit {\tint x, y; // 현재 위치\tabstract void move(int x, int y);\tvoid stop() { /* 현재 위치에 정지 */ }}class Marine extends Unit { // 보병\tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }\tvoid stimPack() { /* 스팀팩을 사용한다. */ }}class Tank extends Unit { // 탱크\tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }\tvoid changeMode() { /* 공격모드로 변환한다. */ }}class Dropship extends Unit { // 수송선\tvoid move(int x, int y) { /* 지정된 위치로 이동 */ }\tvoid load() { /* 선택된 대상을 태운다. */ }\tvoid unload() { /* 선택된 대상을 내린다. */ }}이 Unit클래스는 다른 유닛을 위한 클래스를 작성하는데 재활용될 수 있을 것이다.출처자바의 정석" }, { "title": "다형성(polymorphism)", "url": "/posts/polymorphism/", "categories": "Java", "tags": "Java, 다형성, polymorphism", "date": "2022-10-20 00:00:00 +0900", "snippet": "다형성이란?여러 가지 형태를 가질 수 있는 능력을 의미하며 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였고, 상속과 깊은 관계가 있다.이를 좀 더 구체적으로 말하자면, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.class Tv {\tboolean power; // 전원상태(on/off)\tint channel; // 채널\tvoid power() { power = !power; }\tvoid channelUp() { ++channel; }\tvoid channelDown() { --channel; }}class CaptionTv extends Tv {\tString text; // 캡션을 보여주기 위한 문자열\tvoid caption() { /* 내용생략 */ }}CaptionTv c = new CaptionTv(); // 모든 맴버들을 사용할 수 있다.Tv t = new CaptionTv(); // Tv클래스의 맴버들(상속받은 맴버포함)만 사용할 수 있다. text와 caption()은 참조변수 t로 사용이 불가능하다.둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 맴버의 개수가 달라진다.Tv t = new CaptionTv(); // 조상타입의 참조변수로 자손 인스턴스를 참조할 수 있다.CaptionTv c = new Tv(); // 컴파일 에러조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.그 이유는 실제 인스턴스인 Tv의 맴버 개수보다 참조변수 c가 사용할 수 있는 맴버 개수가 더 많기 때문에 허용하지 않는다.참조변수의 형변환참조변수도 형변환이 가능하다. 단, 서로 상속관계에 있는 클래스사이에서만 가능하다.기본형 변수의 형변환에서 작은 자료형에서 큰 자료형의 형변환은 생략이 가능하듯이, 참조변수의 형변환에서는 아래와 같이 할 수 있다.자손타입 → 조상타입 (Up-casting) : 형변환 생략가능자손타입 ← 조상타입 (Down-casting) : 형변환 생략불가class Car {\tString color;\tint door;\tvoid drive() { // 운전하는 기능\t\tSystem.out.println(\"drive, Brrrr~\");\t}\tvoid stop() { // 멈추는 기능\t\tSystem.out.println(\"stop!!!\");\t}}class FireEngine extends Car { // 소방차\tvoid water() { // 물 뿌리는 기능\t\tSystem.out.println(\"water!!!\");\t}}class Ambulance extends Car { // 앰뷸런스\tvoid siren() { // 사이렌을 울리는 기능\t\tSystem.out.println(\"siren~~~\");\t}}class CastingTest1 {\tCar car = null;\tFireEngine fe = new FireEngine();\tFireEngine fe2 = null;\tfe.water();\tcar = fe; // car = (Car)fe;에서 형변환 생략됨. 업캐스팅// car.water(); // 컴파일 에러!!! Car타입의 참조변수로는 water()를 호출할 수 없다.\tfe2 = (FireEngine)car; // 형변환 생략불가. 다운캐스팅\tfe2.water();}형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 맴버의 범위(개수)를 조절하는 것뿐이다.class CastingTest2 {\tpublic static void main(String[] args) {\t\tCar car = new Car();\t\tCar car2 = null;\t\tFireEngine fe = null;\t\tcar.drive();\t\tfe = (FireEngine)car; // 컴파일은 OK. 실행 시 에러가 발생\t\tfe.drive();\t\tcar2 = fe;\t\tcar2.drive();\t}}서로 상속관계에 있는 클래스 타입의 참조변수간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, 참조변수가 참조하고 있는 인스턴스의 자손타입으로 형변환을 하는 것은 허용되지 않는다. 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다.instanceof연산자참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자를 사용한다. 주로 조건문에 사용되며, instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치하고 연산결과로 true와 false을 반환한다.instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.class InstanceofTest {\tpublic static void main(String[] args) {\t\tFireEngine fe = new FireEngine();\t\tif(fe instanceof FireEngine) {\t\t\tSystem.out.printlf(\"This is a FireEngine instance.\");\t\t}\t\tif(fe instanceof Car) {\t\t\tSystem.out.printlf(\"This is a Car instance.\");\t\t}\t\tif(fe instanceof Object) {\t\t\tSystem.out.printlf(\"This is a Object instance.\");\t\t}\t\tSystem.out.println(fe.getClass().getName()); // 클래스의 이름을 출력\t}}class Car {}class FireEngine extends Car {}/*[실행결과]This is a FireEngine instance.This is a Car instance.This is a Object instance.FireEngine*/위에 예제를 요약하면, 실제 인스턴스와 같은 타입의 instanceof연산 이외의 조상타입의 instanceof연산에도 true를 결과로 얻으며, true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.참조변수와 인스턴스의 연결맴버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 맴버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 맴버변수가 사용된다.메서드의 경우 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출된다.class BindingTest {\tpublic static void main(String[] args) {\t\tParent p = new Child();\t\tChild c = new Child();\t\tSystem.out.println(\"p.x = \" + p.x);\t\tp.method();\t\tSystem.out.println(\"c.x = \" + c.x);\t\tc.method();\t}}class Parent {\tint x = 100;\tvoid method() {\t\tSystem.out.println(\"Parent Method\");\t}}class Child extends Parent {\tint x = 200;\tvoid method() {\t\tSystem.out.println(\"Child Method\");\t}}/*[실행결과]p.x = 100Child Methodc.x = 200Child Method*/매개변수의 다형성참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.class Product {\tint price; // 제품의 가격\tint bonusPoint; // 제품구매 시 제공하는 보너스점수\tProduct(int price) {\t\tthis.price = price;\t\tbonusPoint = (int)(price/10.0); // 보너스점수는 제품가격의 10%\t}}class Tv extends Product {\tTv() {\t\t// 조상클래스의 생성자 Product(int price)를 호출한다.\t\tsuper(100); // Tv의 가격을 100만원으로 한다.\t}\tpublic String toString() { // Object클래스의 toString()을 오버라이딩한다.\t\treturn \"Tv\";\t}}class Computer extends Product {\tComputer() {\t\tsuper(200);\t}\tpublic String toString() {\t\treturn \"Computer\";\t}}class Buyer { // 고객, 물건을 사는 사람\tint money = 1000; // 소유금액\tint bonusPoint = 0; // 보너스점수\tvoid buy(Product p) {\t\tif(money &lt; p.price) {\t\t\tSystem.out.println(\"잔액이 부족하여 물건을 살 수 없습니다.\");\t\t\treturn;\t\t}\t\tmoney -= p.price; // 가진 돈에서 구입한 제품의 가격을 뺸다.\t\tbonusPoint += p.bonusPoint; // 제품의 보너스점수를 추가한다.\t\tSystem.out.println(p + \"을/를 구입하셨습니다.\");\t}}class PolyArgumentTest {\tpublic static void main(String[] args) {\t\tBuyer b = new Buyer();\t\tb.buy(new Tv());\t\tb.buy(new Computer());\t\tSystem.out.println(\"현재 남은 돈은 \" + b.money + \"만원입니다.\");\t\tSystem.out.println(\"현재 보너스점수는 \" + b.bonusPoint + \"점입니다.\");\t}}/*[실행결과]Tv을/를 구입하셨습니다.Computer을/를 구입하셨습니다.현재 남은 돈은 700만원입니다.현재 보너스점수는 30점입니다.*/매개변수의 다형성을 적용한 buy메서드의 매개변수가 Product타입의 참조변수라는 것은 메서드의 매개변수로 Product클래스의 자손타입 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 뜻이다.여러 종류의 객체를 배열로 다루기조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.Product p[] = new Product[3];p[0] = new Tv();p[1] = new Computer();p[2] = new Audio();Product배열의 크기가 3으로 배열의 크기가 고정되어있다. 그렇다고 해서 배열의 크기를 무조건 크게 설정할 수만도 없는 일이다.이런 경우, Vector클래스를 사용하면 된다. Vector클래스는 동적으로 크기가 관리되는 객체배열이다.출처자바의 정석" }, { "title": "제어자(modifier)", "url": "/posts/modifier/", "categories": "Java", "tags": "Java, 제어자, modifier", "date": "2022-10-19 00:00:00 +0900", "snippet": "제어자란?제어자는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.제어자의 종류 접근제어자 public, protected, default, private 그 외 static, final, abstract, native, transient, synchronized, volatile, strictfp 제어자는 하나의 대상에 대해 여러 제어자를 조합하여 사용하는 것이 가능하다.단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.static - 클래스의, 공통적인static은 클래스의 또는 공통적인의 의미를 가지고 있다. 클래스변수(static맴버변수)는 인스턴스에 관계없이 같은 값을 갖는다.static이 사용될 수 있는 곳맴버변수, 메서드, 초기화 블럭class StaticTest {\tstatic int width = 200; // 클래스 변수(static변수)\tstatic int height = 120; // 클래스 변수(static변수)\tstatic { // 클래스 초기화 블럭\t\t// static변수의 복잡한 초기화 수행\t}\tstatic int max(int a, int b) { // 클래스 메서드(static 메서드)\t\treturn a &gt; b ? a : b;\t}}final - 마지막의, 변경될 수 없는final은 마지막의 또는 변경될 수 없는의 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.final이 사용될 수 있는 곳클래스, 메서드, 맴버변수, 지역변수final class FinalTest { // 조상이 될 수 없는 클래스\tfinal int MAX_SIZE = 10; // 값을 변경할 수 없는 맴버변수(상수)\tfinal int getMaxSize() { // 오버라이딩할 수 없는 메서드(변경불가)\t\tfinal int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수(상수)\t\treturn MAX_SIZE;\t}}abstract - 추상의, 미완성의abstract는 미완성의 의미를 가지고 있다. 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.abstract가 사용될 수 있는 곳클래스, 메서드abstract class AbstractTest { // 추상 클래스(추상 메서드를 포함한 클래스)\tabstract void move(); // 추상 메서드(구현부가 없는 메서드)}접근 제어자(access modifier)접근 제어자는 맴버 또는 클래스에 사용되고 외부에서 접근하지 못하도록 제한하는 역할을 한다.접근 제어자가 사용될 수 있는 곳클래스, 맴버변수, 메서드, 생성자 public 접근 제한이 전혀 없다. (전체) protected 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능하다. default 같은 패키지 내에서만 접근이 가능하다. private 같은 클래스 내에서만 접근이 가능하다. 대상에 따라 사용할 수 있는 접근 제어자 대상 사용가능한 접근 제어자 클래스 public, (default) 메서드, 맴버변수 public, protected, (default), private 지역변수 없음 접근 제어자를 이용한 캡슐화접근 제어자를 사용하는 이유 외부로부터 데이터를 보호하기 위해서 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서만일 메서드 하나를 변경해야 한다고 가정했을 때, 이 메서드의 접근제어자가 public이라면, 메서드를 변경한 후에 오류가 없는지 테스트해야하는 범위가 넓다. 그러나 default라면 패키지 내부만 확인해보면 되고 private이면 클래스 하나만 살펴보면 된다.이처럼 접근 제어자를 적절히 선택해서 접근 범위를 최소화하도록 노력해야 한다.class Time {\t// 접근 제어자를 private으로 하여 외부에서 직접 접근하지 못하도록 한다.\tprivate int hour;\tpublic int getHour() {\t\treturn hour;\t}\tpublic void setHour(int hour) {\t\tif(hour &lt; 0 || hour &gt; 23) return;\t\tthis.hour = hour;\t}}생성자의 접근 제어자생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다. 보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다.final class Singleton {\tprivate static Singleton s = new Singleton(); // getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static이어야 한다.\tprivate Singleton() {\t\t// ...\t}\tpublic static Singleton getInstance() {\t\tif(s == null) {\t\t\ts = new Singleton();\t\t}\t\treturn s;\t}\t// ...}class SingletonText {\tpublic static void main(String[] args) {//\t\tSingleton s = new Singleton(); // 에러. private 이라 인스턴스를 생성할 수 없다.\t\tSingleton s = Singleton.getInstance();\t}}제어자(modifier)의 조합대상에 따라 사용할 수 있는 제어자 대상 사용가능한 제어자 클래스 public, (default), final, abstract 메서드 모든 접근 제어자, final, abstract, static 맴버변수 모든 접근 제어자, final, static 지역변수 final 제어자를 조합해서 사용할 때 주의해야 할 사항 메서드에 static과 abstract를 함께 사용할 수 없다. static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다. 클래스에 abstract와 final을 동시에 사용할 수 없다. 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다. abstract메서드의 접근 제어자가 private일 수 없다. abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다. 메서드에 private과 final을 같이 사용할 필요는 없다. 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다. 출처자바의 정석" }, { "title": "package와 import", "url": "/posts/package-import/", "categories": "Java", "tags": "Java, package, import", "date": "2022-10-14 00:00:00 +0900", "snippet": "패키지(package)패키지란, 클래스의 묶음이다. 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다. 모든 클래스는 반드시 하나의 패키지에 속해야 한다. 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다. 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.패키지의 선언클래스나 인터페이스의 소스파일(.java)에 다음과 같이 한 줄만 적어주면 된다.package 패키지명;패키지를 선언하지 않고도 아무런 문제가 없다. 그 이유는 이름없는 패키지(unnamed package) 때문이다.import문클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략할 수 있다.컴파일 시에 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여 준다.import문의 선언package문 다음에 클래스 선언문 이전에 위치해야 한다.import 패키지명.클래스명;또는import 패키지명.*;System과 String같은 java.lang패키지는 매우 빈번히 사용되는 중요한 클래스들이 속한 패키지이기 때문에 모든 소스파일에는 묵시적으로 java.lang패키지가 import문이 선언되어 있다.static import문static import문을 사용하면 static맴버를 호출할 때 클래스 이름을 생략할 수 있다. 특정 클래스의 static맴버를 자주 사용할 때 편리하다.import static java.lang.Integer.*; // Integer클래스의 모든 static메서드import static java.lang.Math.random; // Math.random()만. 괄호 안붙임.import static java.lang.System.out; // System.out을 out만으로 참조가능import static java.lang.System.out;import static java.lang.Math.*;class StaticImportEx1 {\tpublic static void main(String[] args) {\t\t// System.out.println(Math.random());\t\tout.println(random());\t\t// System.out.println(\"Math.PI : \" + Math.PI);\t\tout.println(\"Math.PI : \" + PI);\t}}출처자바의 정석" }, { "title": "오버라이딩(overriding)", "url": "/posts/overriding/", "categories": "Java", "tags": "Java, 오버라이딩, overriding", "date": "2022-10-13 00:00:00 +0900", "snippet": "오버라이딩이란?조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것이다. 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스에 맞게 변경해야하는 경우 오버라이딩한다.class Point {\tint x;\tint y;\tString getLocation() {\t\treturn \"x :\" + x + \", y :\" + y;\t}}class Point3D extends Point {\tint z;\tString getLocation() { // 오버라이딩\t\treturn \"x :\" + x + \", y :\" + y + \", z :\" + z;\t}}오버라이딩의 조건자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와 선언부가 같아야 한다. 이름이 같아야 한다. 매개변수가 같아야 한다. 반환타입이 같아야 한다.다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.ex) 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 한다. 넓은 것에서 좁은 것 순으로 나열 : public, protected, (default), private 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. class Parent { \tvoid parentMethod() throws IOException, SQLException { \t\t// ... \t} } class Child extends Parent { \tvoid parentMethod() throws IOException { // 예외의 개수가 적으므로 가능 \t\t// ... \t} } class Child2 extends Parent { \tvoid parentMethod() throws Exception { // 예외의 개수가 적지만 Exception은 모든 예외의 최고 조상이므로 불가능 \t\t// ... \t} } 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다. static메서드를 똑같은 이름의 static메서드로 정의할 수 있지만 이것은 각 클래스에 별개의 static메서드를 정의한 것일 뿐 오버라이딩이 아니다. 오버로딩 vs. 오버라이딩오버로딩(overloading) 기존에 없는 새로운 메서드를 정의하는 것(new)오버라이딩(overriding) 상속받은 메서드의 내용을 변경하는 것(change, modify)class Parent {\tvoid parentMethod() {}}class Child extends Parent {\tvoid parentMethod() {} // 오버라이딩\tvoid parentMethod(int i) {} // 오버로딩\tvoid childMethod() {}\tvoid childMethod(int i) {} // 오버로딩\tvoid childMethod() {} // 에러. 중복정의 되었음}super자손 클래스에서 조상 클래스로부터 상속받은 맴버를 참조하는데 사용되는 참조변수이다. 맴버변수와 지역변수의 이름이 같을 때 this를 사용해서 구별했듯이 상속받은 맴버와 자신의 클래스에 정의된 맴버의 이름이 같을 때는 super를 사용해서 구별할 수 있다.class SuperTest {\tpublic static void main(String[] args) {\t\tChild c = new Child();\t\tc.method();\t}}class Parent {\tint x = 10;}class Child extends Parent {\tvoid method() {\t\tSystem.out.println(\"x = \" + x);\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}/*[실행결과]x = 10this.x = 10super.x = 10*/이 경우 x, this.x, super.x 모두 같은 변수를 의미한다.class SuperTest2 {\tpublic static void main(String[] args) {\t\tChild c = new Child();\t\tc.method();\t}}class Parent {\tint x = 10;}class Child extends Parent {\tint x = 20;\tvoid method() {\t\tSystem.out.println(\"x = \" + x);\t\tSystem.out.println(\"this.x = \" + this.x);\t\tSystem.out.println(\"super.x = \" + super.x);\t}}/*[실행결과]x = 20this.x = 20super.x = 10*/같은 이름의 맴버변수가 조상 클래스에 있고 자손 클래스에도 있을 때는 super.x와 this.x는 서로 다른 값을 참조하게 된다.super() - 조상 클래스의 생성자this()와 마찬가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.Object클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자, this() 또는 super()를 호출해야 한다. 그렇지 않으면 컴파일러가 자동적으로 super();를 생성자의 첫 줄에 삽입한다.class PointTest {\tpublic static void main(String[] args) {\t\tPoint3D p3 = new Point3D(1, 2, 3);\t}}class Point {\tint x;\tint y;\tPoint(int x, int y) {\t\tthis.x = x;\t\tthis.y = y;\t}\tString getLocation() {\t\treturn \"x : \" + x + \", y : \" + y;\t}}class Point3D extends Point {\tint z;\tPoint3D(int x, int y, int z) {\t\t// 생성자 첫 줄에 다른 생성자를 호출하지 않기 때문에 컴파일러가 'super();'를 여기에 삽입한다.\t\t// super()는 Point3D의 조상인 Point클래스의 기본 생성자인 Point()를 의미한다.\t\t// 하지만 조상 클래스의 Point()가 없기 때문에 컴파일에러가 발생할 것이다.\t\tthis.x = x;\t\tthis.y = y;\t\tthis.z = z;\t}\tString getLocation() { // 오버라이딩\t\treturn \"x : \" + x + \", y : \" + y + \", z : \" + z;\t}}아래처럼 변경하면 문제없이 컴파일 될 것이다.Point3D(int x, int y, int z) {\tsuper(x, y); // 조상클래스의 생성자 Point(int x, int y)를 호출한다.\tthis.z = z;}출처자바의 정석" }, { "title": "상속(inheritance)", "url": "/posts/inheritance/", "categories": "Java", "tags": "Java, 상속, inheritance", "date": "2022-10-12 00:00:00 +0900", "snippet": "상속의 정의와 장점기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.class Parent {\t// ...}class Child extends Parent { // 상속받고자 하는 클래스의 이름을 extends와 함께 써준다.\t// ...}상속해주는 클래스를 조상 클래스, 상속 받는 클래스를 자손 클래스라 하는데 아래와 같은 용어로 표현하기도 한다.조상 클래스 = 부모 클래스, 상위 클래스, 기반 클래스자손 클래스 = 자식 클래스, 하위 클래스, 파생된 클래스조상 클래스가 변경되면 자손 클래스는 자동적으로 영향을 받게 되지만, 자손 클래스가 변경되는 것은 조상 클래스에 아무런 영향을 주지 못한다. 생성자와 초기화 블럭은 상속되지 않는다. 맴버만 상속된다. 자손 클래스의 맴버 개수는 조상 클래스보다 항상 같거나 많다.class Tv {\tboolean power; // 전원상태(on/off)\tint channel; // 채널\tvoid power() { power = !power; }\tvoid channelUp() { ++channel; }\tvoid channelDown() { --channel; }}class CaptionTv extends Tv {\tboolean caption; // 캡션상태(on/off)\tvoid displayCaption(String text) {\t\tif(caption) { // 캡션상태가 on(true)일 때만 text를 보여 준다.\t\t\tSystem.out.println(text);\t\t}\t}}class CaptionTest {\tpublic static void main(String[] args) {\t\tCaptionTv ctv = new CaptionTv();\t\tctv.channel = 10; // 조상 클래스로부터 상속받은 맴버\t\tctv.channelUp(); // 조상 클래스로부터 상속받은 맴버\t\tSystem.out.println(ctv.channel);\t\tctv.displayCaption(\"Hello, World\");\t\tctv.caption = true; // 캡션기능을 켠다.\t\tctv.displayCaption(\"Hello, World\"); // 캡션을 화면에 보여준다.\t}}/*[실행결과]11Hello, World*/자손 클래스의 인스턴스를 생성하면 조상 클래스의 맴버와 자손 클래스의 맴버가 합쳐진 하나의 인스턴스로 생성된다.클래스간의 관계 - 포함관계상속이외에도 클래스를 재사용하는 또 다른 방법은 포함(Composite)관계를 맺어 주는 것이다.class Circle {\tPoint c = new Point(); // 포함관계\tint r // 반지름}class Point {\tint x; // x좌표\tint y; // y좌표}클래스간의 관계 결정하기상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 결정하는 것은 때때로 혼돈스러울 수 있다.class Circle {\tPoint c = new Point();\tint r;}class Circle extends Point {\tint r;}위에 두 경우에 별 차이가 없어 보인다. 그럴 때는 아래처럼 문장을 만들어 보면 클래스 간의 관계가 보다 명확해 진다. 원(Circle)은 점(Point)이다. - Circle is a Point 원(Circle)은 점(Point)을 가지고 있다. - Circle has a Point아래 문장이 더 옳다는 것을 알수 있다. 그래서 위에 관계는 상속관계 보다 포함관계를 맺어주는 것이 더 옳다. 상속관계 ‘~은 ~이다.(is-a)’ 포함관계 ‘~은 ~을 가지고 있다.(has-a)’class DrawShape {\tpublic static void main(String[] args) {\t\tPoint[] p = { new Point(100, 100), new Point(140, 50), new Point(200, 100)\t\t\t\t\t\t\t\t};\t\tTriangle t = new Triangle(p);\t\tCircle c = new Circle(new Point(150, 150), 50);\t\tt.draw(); // 삼각형을 그린다.\t\tc.draw(); // 원을 그린다.\t}}class Shape {\tString color = \"black\";\tvoid draw() {\t\tSystem.out.printf(\"[color=%s]%n\", color);\t}}class Point {\tint x;\tint y;\tPoint(int x, int y) {\t\tthis.x = x;\t\tthis.y = y;\t}\tPoint() {\t\tthis(0, 0);\t}\tString getXY() {\t\treturn \"{\" + x + \", \" + y + \")\"; // x와 y값을 문자열로 반환\t}}class Circle extends Shape {\tPoint center; // 원의 원점좌표\tint r; // 반지름\tCircle() {\t\tthis(new Point(0, 0), 100); // Circle(Point center, int r)를 호출\t}\tCircle(Point center, int r) {\t\tthis.center = center;\t\tthis.r = r;\t}\tvoid draw() { // 원을 그리는 대신에 원의 정보를 출력하도록 했다.\t\tSystem.out.printf(\"[center=(%d, %d), r=%d, color=%s]%n\", center.x, center.y, r, color);\t}}class Triangle extends Shape {\tPoint[] p = new Point[3];\tTriangle(Point[] p) {\t\tthis.p = p;\t}\tvoid draw() {\t\tSystem.out.printf(\"[p1=%s, p2=%s, p3=%s, color=%s]%n\", p[0].getXY(), p[1].getXY(), p[2].getXY(), color);\t}}[실행결과][p1=(100,100), p2=(140,50), p3=(200,100), color=black][center=(150, 150), r=50, color=black]위에 예제로 클래스간의 관계를 맺어보자.A Circle is a Shape. // 1. 원은 도형이다.A Circle is a Point. // 2. 원은 점이다?A Circle has a Shape. // 3. 원은 도형을 가지고 있다?A Circle has a Shape. // 4. 원은 점을 가지고 있다.1번, 4번 문장이 자연스럽다는 것을 쉽게 알 수 있다. 이렇게 문장을 만들어보면 클래스간의 관계를 결정할 때 감을 잡을 수 있을 것이다.단일 상속(single inheritance)자바에서는 단일 상속만을 허용한다.class TVCR extends TB, VCR { // 에러. 조상은 하나만 허용된다.}Object클래스 - 모든 클래스의 조상Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스이다. 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.class Tv {}위에 코드를 컴파일 하면 컴파일러는 자동적으로 ‘extends Object’를 추가하여 Tv클래스가 Object클래스를 상속받도록 한다.만일 다른 클래스로부터 상속을 받는다고 하더라도 결국 마지막 최상위 조상은 Object클래스일 것이다." }, { "title": "변수의 초기화", "url": "/posts/initialization-variables/", "categories": "Java", "tags": "Java, 변수의 초기화", "date": "2022-10-07 00:00:00 +0900", "snippet": "변수의 초기화변수를 선언하고 처음으로 값을 저장하는 것을 변수의 초기화라고 한다.class InitTest {\tint x; // 인스턴스 변수\tint y = x; // 인스턴스 변수\tvoid method1() {\t\tint i; // 지역변수\t\tint j = i; // 에러. 지역변수를 초기화하지 않고 사용\t}}맴버변수(클래스변수와 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.맴버변수의 초기화 방법 명시적 초기화 생성자 초기화 블럭 인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용. 클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용. 명시적 초기화(explicit initialization)변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 한다.여러 초기화 방법 중에서 가장 우선적으로 고려되어야 한다.class Car {\tint door = 4; // 기본형(primitive type) 변수의 초기화\tEngine e = new Engine(); // 참조형(reference type) 변수의 초기화}보다 복잡한 초기화 작업이 필요할 때는 초기화 블럭 또는 생성자를 사용해야 한다.초기화 블럭(initialization block)초기화 블럭에는 두 가지 종류가 있다. 클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용된다. 인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용된다.class InitBlock {\tstatic { // 클래스 초기화 블럭\t}\t{ // 인스턴스 초기화 블럭\t}}클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행된다.생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.class StaticBlockTest {\tstatic int[] arr = new int[10]; // 명시적 초기화를 통해 배열 arr 생성\tstatic { // 클래스 초기화 블럭\t\tfor(int i = 0; i &lt; arr.length; i++) {\t\t\t// 1과 10사이의 임의의 값을 배열 arr에 저장한다.\t\t\tarr[i] = (int)(Math.random() * 10) + 1;\t\t}\t}\tpublic static void main(String[] args) {\t\tfor(int i = 0; i &lt; arr.length; i++) {\t\t\t// 1과 10사이의 임의의 값이 출력된다.\t\t\tSystem.out.println(\"arr[\" + i + \"] : \" + arr[i]);\t\t}\t}}이처럼 배열이나 예외처리가 필요한 초기화에서는 명시적 초기화만으로는 복잡한 초기화 작업을 할 수 없다. 이런 경우에 추가적으로 클래스 초기화 블럭을 사용하도록 한다.인스턴스변수의 복잡한 초기화는 생성자 또는 인스턴스 초기화 블럭을 사용한다.맴버변수의 초기화 시기와 순서클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다.인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.클래스변수의 초기화순서 : 기본값 → 명시적 초기화 → 클래스 초기화 블럭인스턴스변수의 초기화순서 : 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자class InitTest {\tstatic int cv = 1; // 명시적 초기화\t int iv = 1; // 명시적 초기화\tstatic { // 클래스 초기화 블럭\t\tcv = 2;\t}\t{ // 인스턴스 초기화 블럭\t\tiv = 2;\t}\tInitTest() { // 생성자\t\tiv = 3;\t}}클래스변수 초기화 : 클래스가 처음 메모리에 로딩될 때 차례대로 수행된다.인스턴스변수 초기화 : 인스턴스를 생성할 때 차례대로 수행된다.클래스변수는 인스턴스변수보다 항상 먼저 생성되고 초기화 된다.출처자바의 정석" }, { "title": "생성자(constructor)", "url": "/posts/constructor/", "categories": "Java", "tags": "Java, 생성자, constructor", "date": "2022-10-06 00:00:00 +0900", "snippet": "생성자란?인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드이다. 따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다.생성자의 조건 생성자의 이름은 클래스의 이름과 같아야 한다. 생성자는 리턴 값이 없다.class Card {\tCard() { // 매개변수가 없는 생성자\t}\tCard(String k, int num) { // 매개변수가 있는 생성자\t}}인스턴스 생성이 수행되는 과정Card c = new Card(); 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다. 생성자 Card()가 호출되어 수행된다. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.기본 생성자(default constructor)모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다. 하지만 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 기본 생성자를 제공해 주기 때문이다. 기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않다.클래스이름() {}Card() {}기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.매개변수가 있는 생성자생성자도 메서드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용할 수 있다.class Car {\tString color; // 색상\tString gearType; // 변속기 종류 - auto(자동), manual(수동)\tint door; // 문의 개수\tCar() { // 생성자\t}\tCar(String c, String g, int d) { //생성자\t\tcolor = c;\t\tgearType = g;\t\tdoor = d;\t}}class CarTest {\tpublic static void main(String[] args) {\t\tCar c1 = new Car();\t\tc1.color = \"white\";\t\tc1.gearType = \"auto\";\t\tc1.door = 4;\t\tCar c2 = new Car(\"white\", \"auto\", 4);\t}}c1 보다 c2 코드가 더 간결하고 직관적이다.이처럼 다양한 생성자를 제공함으로써 인스턴스 생성 후에 별도로 초기화를 하지 않아도 되도록 하는 것이 바람직하다.생성자에서 다른 생성자 호출하기 - this(), this생성자 간에도 서로 호출이 가능하다. 단, 다음의 두 조건을 만족시켜야 한다. 생성자의 이름으로 클래스이름 대신 this를 사용한다. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.class Car {\tString color;\tString gearType;\tint door;\tCar() { // Car(String color, String gearType, int door)를 호출\t\tthis(\"white\", \"auto\", 4);\t}\tCar(String color) {\t\tthis(color, \"auto\", 4);\t}\tCar(String color, String gearType, int door) {\t\tthis.color = color;\t\tthis.gearType = gearType;\t\tthis.door = door;\t}}this인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.this(), this(매개변수)생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.생성자를 이용한 인스턴스의 복사현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자를 이용할 수 있다. 인스턴스의 차이는 인스턴스마다 각기 다른 값을 가질 수 있는 인스턴스변수 뿐이다.class Car {\tString color;\tString gearType;\tint door;\tCar() {\t\tthis(\"white\", \"auto\", 4);\t}\tCar(Car c) { // 인스턴스의 복사를 위한 생성자\t\t/*\t\tc.color = color;\t\tc.gearType = gearType;\t\tc.door = door;\t\t*/\t\t// 아래와 같이 다른 생성자를 호출하는 것이 바람직하다.\t\tthis(c.color, c.gearType, c.door);\t}\tCar(String color, String gearType, int door) {\t\tthis.color = color;\t\tthis.gearType = gearType;\t\tthis.door = door;\t}}class CarTest {\tpublic static void main(String[] args) {\t\tCar c1 = new Car();\t\tCar c2 = new Car(c1); // c1의 복사본 c2를 생성한다.\t}}출처자바의 정석" }, { "title": "오버로딩(overloading)", "url": "/posts/overloading/", "categories": "Java", "tags": "Java, 오버로딩, overloading", "date": "2022-10-05 00:00:00 +0900", "snippet": "오버로딩이란?한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것이다.오버로딩의 조건 메서드 이름이 같아야 한다. 매개변수의 개수 또는 타입이 달라야 한다.오버로딩의 예가장 대표적인 것은 println메서드이다. println메서드를 호출할 때 매개변수로 지정하는 값의 타입에 따라서 호출되는 println메서드가 달라진다.[보기1] 매개변수의 타입과 개수가 같기 때문에 오버로딩이 성립하지 않는다.int add(int a, int b) { return a + b; }int add(int x, int y) { return x + y; }[보기2] 매개변수의 타입과 개수가 같기 때문에 오버로딩이 성립하지 않는다.int add(int a, int b) { return a + b; }long add(int a, int b) { return (long)(a + b); }[보기3] 매개변수의 순서가 다르기 때문에 오버로딩이 성립한다.int add(int a, long b) { return a + b; }long add(long a, int b) { return a + b; }[보기4] 매개변수의 타입과 개수가 다르기 때문에 오버로딩이 성립한다.int add(int a, int b) { return a + b; }long add(long a, long b) { return a + b; }long add(int[] a) { // 배열의 모든 요소의 합을 반환한다.\tlong result = 0;\tfor(int i = 0; i &lt; a.length; i++) {\t\tresult += a[i];\t}\treturn result;}[보기4] 처럼 같은 일을 하지만 매개변수를 달리해야하는 경우에 오버로딩을 구현한다.오버로딩의 장점하나의 이름으로 정의되므로 기억하기도 쉽고 이름도 짧게 할 수 있어서 오류의 가능성을 많이 줄일 수 있다.메서드의 이름만 보고도 이 메서드들은 이름이 같으니, 같은 기능을 하겠구나. 라고 쉽게 예측할 수 있다.메서드의 이름을 절약할 수 있다.가변인자(varargs)와 오버로딩가변인자란?JDK1.5부터 매개변수 개수를 동적으로 지정해 줄 수 있게 되었으며, 이 기능을 가변인자(variable arguments) 라고 한다.타입… 변수명 과 같은 형식으로 선언하며, printf()가 대표적인 예이다.public PrintStream printf(String format, Object... args) { ... }가변인자 외에도 다른 매개변수가 더 있다면 가변인자를 제일 마지막에 선언해야 한다.static String concatenate(String delim, String... args) {\tString result = \"\";\tfor(String str : args) {\t\tresult += str + delim;\t}\treturn result;}static String concatenate(String... args) {\treturn concatenate(\"\", args);}위에 concatenate메서드처럼 오버로딩하면 컴파일러는 어떤 메소드를 사용 해야하는지 구분을 못하고 컴파일 에러가 난다.가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 구별되지 못하는 경우가 발생하기 쉽기 때문에 가능하면 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.출처자바의 정석" }, { "title": "변수와 메서드", "url": "/posts/variables-method/", "categories": "Java", "tags": "Java, 변수, 메서드", "date": "2022-09-30 00:00:00 +0900", "snippet": "선언위치에 따른 변수의 종류변수는 클래스변수, 인스턴스변수, 지역변수가 있다.변수의 종류를 결정짓는 중요한 요소는 ‘변수의 선언된 위치’ 다.맴버변수를 제외한 나머지 변수들은 모두 지역변수이며, 맴버변수 중 static이 붙는 것은 클래스변수, 붙지 않는 것은 인스턴스변수이다.class Variables {\t// 클래스영역\tint iv; // 인스턴스변수\tstatic int cv; // 클래스변수(static변수, 공유변수)\tvoid method() {\t\t// 메서드영역\t\tint lv = 0; // 지역변수\t}}변수의 종류와 특징 변수의 종류 선언위치 생성시기 클래스변수 클래스영역 클래스가 메모리에 올라갈 때 인스턴스변수 클래스영역 인스턴스가 생성되었을 때 지역변수 클래스영역 이외의 영역   (메서드, 생성자, 초기화 블럭 내부) 변수 선언문이 수행되었을 때   인스턴스변수(instance variable)클래스의 인스턴스를 생성할 때 만들어진다. 그렇기 때문에 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야한다. 인스턴스는 서로 다른 값을 가질 수 있어서 인스턴스마다 고유한 상태를 유지해야하는 경우, 인스턴스변수로 선언한다.클래스변수(class variable)인스턴스변수 앞에 static을 붙이기만 하면 된다. 인스턴스변수와는 달리 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다. 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 경우, 클래스변수로 선언한다.인스턴스를 생성하지 않고도 ‘클래스이름.클래스변수’와 같은 형식으로 바로 사용할 수 있다. 클래스가 메모리에 ’로딩’될 때 생성되어 프로그램이 종료될 때 까지 유지되며, public을 앞에 붙이면 어디서나 접근할 수 있는 ’전역변수’가 된다.지역변수(local variable)메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.클래스변수와 인스턴스변수인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다.메서드특정 작업을 수행하는 문장들을 하나로 묶은 것이다.메서드에 넣을 값(입력)과 반환하는 결과(출력)만 알면 된다.메서드를 사용하는 이유 높은 재사용성 한번 만들어 놓은 메서드는 몇 번이고 호출할 수 있다. 중복된 코드의 제거 반복되는 문장들을 묶어서 하나의 메서드로 작성한다. 프로그램의 구조화 문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화시키는 것이 필수적이다. 메서드의 선언과 구현선언부와 구현부로 이루어져 있다.반환타입 메서드이름 (매개변수1, 매개변수2, ...) { // 선언부\t// 구현부\t// 메서드 호출 시 수행될 코드}메서드 선언부반환타입(출력), 메서드이름, 매개변수 선언(입력)으로 구성되어 있다.매개변수 선언메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것이다. 매개변수도 지역변수다.메서드이름이름만으로도 메서드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓도록 노력해야 한다.반환타입메서드의 작업수행 결과(출력)인 반환값의 타입을 적는다. 반환값이 없는 경우 ‘void’ 를 적어야 한다.메서드의 구현부메서드를 호출했을 때 수행될 문장들을 넣는다.return문메서드의 반환타입이 ‘void’가 아닌 경우, 구현부{}안에 ‘return 반환값;’이 반드시 포함되어 있어야 한다.지역변수지역변수는 메서드 내의 선언된 변수이고, 그 메서드 내에서만 사용할 수 있다.메서드의 호출메서드를 호출해야만 구현부{}의 문장들이 수행된다.메서드이름(값1, 값2, ...) // 메서드 호출 방법인자와 매개변수메서드를 호출할 때 괄호안에 넣는 값을 인자 또는 인수라고 한다.int result = add(3, 5); // 3, 5 인자int add(int x, int y) { // x, y 매개변수\tint result = x + y;\treturn result;}return문현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다.void 인 경우 컴파일러가 자동으로 return; 을 추가해준다.JVM의 메모리구조응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 method area, call stack, heap 영역으로 나누어 관리한다.메서드영역(method area)어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일을 읽어서 클래스에 대한 정보(클래스 데이터, 클래스변수)를 이곳에 저장한다.힙(heap)인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수들이 생성되는 공간이다.호출스택(call stack 또는 execution stack)메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.class CallStackTest2 {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"main(String[] args)이 시작되었음.\");\t\tfirstMethod();\t\tSystem.out.println(\"main(String[] args)이 끝났음.\");\t}\tstatic void firstMethod() {\t\tSystem.out.println(\"firstMethod()이 시작되었음.\");\t\tsecondMethod();\t\tSystem.out.println(\"firstMethod()이 끝났음.\");\t}\tstatic void secondMethod() {\t\tSystem.out.println(\"secondMethod()이 시작되었음.\");\t\tSystem.out.println(\"secondMethod()이 끝났음.\");\t}}[실행결과]main(String[] args)이 시작되었음.firstMethod()이 시작되었음.secondMethod()이 시작되었음.secondMethod()이 끝났음.firstMethod()이 끝났음.main(String[] args)이 끝났음.기본형 매개변수와 참조형 매개변수기본형 매개변수 - 변수의 값을 읽기만 할 수 있다. (read only) ex) int, boolean 등참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다. (read &amp; write) ex) 배열, 객체참조형 반환타입반환타입이 ‘참조형’ 이라는 것은 메서드가 ’객체의 주소’를 반환한다는 것을 의미한다.재귀호출(recursive call)메서드의 내부에서 메서드 자신을 다시 호출하는 것이라 하고, 재귀호출을 하는 메서드를 ‘재귀 메서드’라 한다.대부분의 재귀호출은 반복문으로 작성하는 것이 가능하지만 재귀호출을 사용하는 이유는 재귀호출이 주는 논리적 간결함 때문이다.재귀호출은 비효율적이므로 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야 한다.클래스 메서드(static메서드)와 인스턴스 메서드변수에서 그랬던 것과 같이, 메서드 앞에 static이 붙어 있으면 클래스 메서드이고 붙어 있지 않으면 인스턴스 메서드이다.클래스의 맴버변수 중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면, static을 붙여준다.작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려한다.long add() { return a + b; } // 인스턴스 메서드static long add(long a, long b) { return a + b; } // 클래스 메서드클래스 맴버와 인스턴스 맴버간의 참조와 호출같은 클래스에 속한 맴버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다.단, 클래스 맴버가 인스턴스 맴버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다.그 이유는 인스턴스 맴버가 존재하는 시점에 클래스 맴버는 항상 존재하지만, 클래스 맴버가 존재하는 시점에 인스턴스 맴버가 존재하지 않을 수도 있기 때문이다.ex) static 메서드 안에 인스턴스 메서드를 호출할 수 없다. static 메서드는 호출할 수 있다.출처자바의 정석" }, { "title": "객체지향 설계 5대 원칙(SOLID)", "url": "/posts/solid/", "categories": "Java", "tags": "Java, 객체지향 설계 5대 원칙, SOLID", "date": "2022-09-27 00:00:00 +0900", "snippet": "객체지향 설계 5대 원칙(SOLID)SOLID란 로버트 마틴이 2000년대 초반에 명명한 객체지향 설계의 5대 원칙을 앞 글자만 딴 것이다.프로그래머가 시간이 지나도 유지보수와 확장이 쉬운 소프트웨어를 만드는데 이 원칙들을 적용할 수 있다. SRP(단일 책임 원칙, Single Responsibility Principle) OCP(개방-폐쇄 원칙, Open/Closed Principle) LSP(리스코프 치환 원칙, Liskov Substitution Principle) ISP(인터페이스 분리 원칙, Interface Segregation Principle) DIP(의존관계 역전 원칙, Dependency Inversion Principle)SRP(단일 책임 원칙, Single Responsibility Principle)어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.한 클래스는 하나의 책임만 가져야 한다.위에 남자 클래스는 역할과 책임이 너무 많다.위처럼 역할과 책임을 알맞게 분리 시키는 것을 단일 책임 원칙을 잘 지켰다고 볼 수 있다.OCP(개방-폐쇄 원칙, Open/Closed Principle)소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.즉, 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.운전자가 마티즈를 운전하다 쏘나타로 자동차를 바꾸면 운전자의 행동에도 수동에서 자동으로 변화가 온다.자동차라는 상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 운전자는 운전 습관에 영향을 받지 않게 된다.다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에는 개방되어 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄되어 있는 것이다.LSP(리스코프 치환 원칙, Liskov Substitution Principle)서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다. 하위 클래스 is a kind of 상위 클래스 : 하위 분류는 상위 분류의 한 종류이다. 구현 클래스 is able to 인터페이스 : 구현 분류는 인터페이스 할 수 있어야 한다.아버지 a = new 딸(); // 불가능(리스코프 치환 원칙 위배)동물 a = new 펭귄(); // 가능(리스코프 치환 원칙 만족)하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.ISP(인터페이스 분리 원칙, Interface Segregation Principle)클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.각 역할에 맞게 인터페이스로 분리하는 것이다.ex) 여자친구를 만날 때는 남자친구 역할만 할 수 있게 인터페이스로 제한한다.결론적으로는 단일 책임 원칙(SRP)과 인터페이스 분리 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.인터페이스 최소 주의 원칙 : 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라.상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다.DIP(의존관계 역전 원칙, Dependency Inversion Principle)추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.자주 변경되는 구체(Concrete) 클래스에 의존하지 마라.자동차가 타이어에 의존하면 어떻게 될까? 자동차 타이어는 자주 바뀌게 되는 것 중 하나다. 이렇게 자주 바뀌는 것에 의존하면 자동차는 영향을 받게 되어 있다.즉, 자동차 자신보다 더 자주 변하는 스노우타이어에 의존하기에 좋지 않음을 알 수 있다.자동차가 구체적인 타이어가 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 타이어가 변경되어도 자동차가 영향을 받지 않는다.자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.출처https://p829911.tistory.com/24https://devlog-wjdrbs96.tistory.com/380" }, { "title": "클래스와 객체", "url": "/posts/class-object/", "categories": "Java", "tags": "Java, 클래스와 객체", "date": "2022-09-23 00:00:00 +0900", "snippet": "클래스와 객체의 정의와 용도클래스정의 : 객체를 정의해놓은 것. 또는 객체의 설계도 또는 틀.용도 : 객체를 생성하는데 사용된다.객체정의 : 실제로 존재하는 것. 사물 또는 개념용도 : 객체가 가지고 있는 기능과 속성에 따라 다름객체와 인스턴스클래스로부터 객체를 만드는 과정 → 클래스의 인스턴스화만들어진 객체 → 그 클래스의 인스턴스객체모든 인스턴스를 대표하는 포괄적인 의미ex) 책상은 객체다.인스턴스어떤 클래스로부터 만들어진 것인지를 강조하는 구체적인 의미ex) 책상은 책상클래스의 인스턴스다.객체의 구성요소 - 속성과 기능객체는 속성과 기능으로 이루어져 있다.속성과 기능을 객체의 맴버(구성원)라 한다.속성은 맴버변수로 기능은 메서드로 정의한다.인스턴스의 생성과 사용클래스를 선언한 것은 설계도를 작성한 것에 불과하고 인스턴스를 생성해야 객체를 사용 가능할 수 있다.클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수 선언변수명 = new 클래스명(); // 클래스의 객체를 생성 후 객체의 주소를 참조변수에 저장ex)TV t;t = new TV();인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.객체 배열객체를 배열로 다루는 것TV tv1, tv2, tv3; -&gt; TV[] tvArr = new TV[3];객체 저장위에는 그저 객체를 다루기 위한 참조변수들이 만들어진 것이고 각 요소에 저장해야한다.TV[] tvArr = new TV[3]; // 참조변수 배열을 생성// 객체를 생성해서 배열의 각 요소에 저장tvArr[0] = new TV();tvArr[1] = new TV();tvArr[2] = new TV();// 한줄로 작성Tv[] tvArr = {new Tv(), new Tv(), new Tv()};// 객체의 수가 많으면 for문 사용Tv[] tvArr = new Tv[100];for(int i = 0; i &lt; tvArr.length; i++) {\ttvArr[i] = new Tv();}클래스의 또 다른 정의클래스는 “객체를 생성하기 위한 틀”이며 “속성과 기능으로 정의되어있다.”고 했다. 이것은 객체지향이론의 관점에서 내린 정의이고, 프로그래밍적인 관점에서 클래스의 정의와 의미는 “데이터와 함수의 결합”이다. 변수 - 하나의 데이터 저장 배열 - 같은 종류의 여러 데이터를 하나의 집합으로 저장 구조체 - 종류에 관계없이 하나의 집합으로 저장 클래스 - 데이터와 함수의 결합(구조체 + 함수)사용자 정의 타입프로그래머가 서로 관련된 변수들을 묶어 하나의 타입으로 추가하는 것객체지향언어에서는 클래스가 곧 사용자 정의 타입이다.// 비객체지향적 코드int hour1, hour2, hour3;int minute1, minute2, minute3;float second1, second2, second3;// 객체지향적 코드// 1. 클래스class Time {\tint hour;\tint minute;\tfloat second;}// 2. 객체배열int[] hour = new int[3];int[] minute = new int[3];float[] second = new float[3];객체지향언어에서는 제어자와 메서드를 이용하여 조건들을 코드에 쉽게 반영할 수 있다.출처자바의 정석https://velog.io/@jacobhboy/자바-12.-클래스와-객체" }, { "title": "객체지향언어", "url": "/posts/object-oriented/", "categories": "Java", "tags": "Java, 객체지향언어", "date": "2022-09-20 00:00:00 +0900", "snippet": "객체지향언어의 역사컴퓨터의 초창기에는 주로 과학실험이나 미사일 발사실험과 같은 모의실험을 목적으로 사용되었다.이 시절의 과학자들은 모의실험을 위해 실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 노력했고 이러한 노력은 객체지향이론을 탄생시켰다.1960년대 중반에 시뮬라라는 최초의 객체지향언어가 탄생하였다.1980년대 중반에 C++ 등 여러 객체지향언어가 발표되면서 개발자들의 관심을 끌기 시작했지만 사용자층이 넓지 못했다.요구사항이 빠르게 변화해가는 상황을 절차적 언어로는 극복하기 어렵다는 한계를 느끼고 객체지향언어를 이용한 개발방법론이 대안으로 떠오르게 되었다.자바가 1995년 발표되고 1990년대 말에 인터넷의 발전과 함께 크게 유행하면서 객체지향언어는 프로그래밍언어의 주류로 자리잡게 되었다.객체지향언어프로그램을 다수의 객체로 만들고, 객체끼리 서로 상호작용하도록 관계를 만드는 프로그래밍 언어특징 캡슐화 데이터와 코드의 형태를 외부로부터 알 수 없게 하고, 데이터의 구조와 역할, 기능을 하나의 캡슐 형태로 만드는 방법이다. (정보 은닉) ex) VO에 private 을 붙이고 getter, setter를 만든다. 상속 부모클래스에 정의된 변수 및 메서드를 자식 클래스에서 그대로 이어 받아 사용하는 것이다. 다형성 상속과 연관된 개념, 하나의 객체가 여러 객체로 재구성 되는 것이다. (오버로딩, 오버라이딩) 추상화 공통의 속성이나 기능을 묶어 이름을 붙이는 것, 객체지향관점에서는 클래스를 정의하는 것. 장점 코드의 재사용성이 높다. (재사용성) 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다. 코드의 관리가 용이하다. (유지보수) 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다. 신뢰성 높은 프로그래밍을 가능하게 한다. (중복된 코드의 제거) 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다. 단점 느린 개발 속도 정확한 이해가 필요하기에 설계단계부터 많은 시간이 소모된다. 느린 실행 속도 컴퓨터가 이해하는데 시간이 걸려 실행속도가 느리다. 출처자바의정석https://xangmin.tistory.com/152https://velog.io/@jacobhboy/자바-10.-객체지향언어" }, { "title": "자바의 특징", "url": "/posts/java-features/", "categories": "Java", "tags": "Java, 자바의 특징", "date": "2022-09-16 00:00:00 +0900", "snippet": "자바란?썬 마이크로시스템즈에서 개발하여 1996년 1월에 공식적으로 발표한 객체지향 프로그래밍 언어이다.자바의 역사1991년 제임스 고슬링과 아서 밴 호프와 같은 썬의 엔지니어들에 의해서 고안된 오크(Oak)라는 언어에서부터 시작되었다.원래 목표는 가전제품에 탑재될 소프트웨어를 만드는 것이었으나 인터넷이 등장하자 운영체제에 독립적인 Oak가 적합하다고 판단하여 개발 방향을 바꾸면서 이름을 자바(Java)로 변경했다.1996년 1월 자바의 정식 버전을 발표했다.2010년에 썬이 오라클(oracle)사에 인수되면서 이제 자바는 오라클사의 제품이 되었다.자바언어의 특징운영체제에 독립적이다.자바에는 많은 특징이 있지만 가장 큰 특징이라면 한번 작성한 프로그램은 운영체제에 상관없이 어디서든 돌려볼 수 있다는 점이다.기존의 언어는 한 운영체제에 맞게 개발된 프로그램을 다른 종류의 운영체제에 적용하기 위해서는 많은 노력이 필요하였지만, 자바는 JVM(자바가상머신)에 의해서 실행되기 때문이다.자바 응용프로그램은 운영체제나 하드웨어가 아닌 JVM하고만 통신하고 JVM이 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달한다.‘한번 작성하면, 어디서나 실행된다.(Write once, run anywhere)’고 표현하기도 한다.객체지향언어이다.자바는 숫자(int, float, long 등)나 논리값(true, false)을 제외한 거의 모든 것이 객체로 구성되어 있다. 실제로 자바는 Object 클래스에서 모든 클래스를 파생한다.자동 메모리 관리(Garbage Collection)자바로 작성된 프로그램이 실행되면, 가비지 컬렉터(GC, Garbage Collector)가 자동적으로 메모리를 관리해주기 때문에 프로그래머는 메모리를 따로 관리하지 않아도 되고 프로그래밍에 집중할 수 있도록 도와준다.C/C++ 등 다른 언어는 사용하지 않는 메모리는 개발자가 해제해야 한다.멀티쓰레드 지원자바는 하나의 프로그램에서 여러 개의 쓰레드가 동시에 실행할 수 있는 환경을 지원합니다.  C/C++은 운영체제의 도움을 받아 멀티 쓰레드를 수행하지만, 자바는 운영체제 지원없이 멀티스레드 프로그래밍이 가능하고 관련된 라이브러리(Java API)가 제공되므로 구현이 쉽다.동적 로딩자바는 애플리케이션 실행 시에 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다는 장점이 있다.일부 클래스가 변경되어도 전체를 컴파일하지 않아도 되며, 애플리케이션의 변경사항이 발생해도 비교적 적은 작업으로 처리할 수 있는 유연성 애플리케이션을 작성할 수 있다.JVM(Java Virtual Machine)JVM은 자바 프로그램이 실행되는 가상 컴퓨터(VM)이다.자바로 작성된 애플리케이션은 모두 이 가상 컴퓨터(JVM)에서만 실행되기 때문에, 자바 애플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다.Java 애플리케이션은 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 프로그램의 변경없이 실행이 가능하다. 일반적으로 많이 사용되는 주요 OS용 JVM을 제공하고 있고, 이렇게 함으로써 자바의 중요한 장점 중의 하나인 “Write once, run anywhere(한번 작성하면, 어디서나 실행된다.)” 이 가능하게 되는 것이다.출처자바의정석https://life-with-coding.tistory.com/430" }, { "title": "IT기업 기술블로그 사이트 모음", "url": "/posts/tech-blog/", "categories": "기술블로그", "tags": "기술블로그", "date": "2022-09-02 00:00:00 +0900", "snippet": "IT기업 기술블로그 사이트 모음기술 블로그 모음IT 기술 블로그들의 최신 포스트를 한곳에서 보는 사이트KaKao Tech우아한형제들 기술블로그Naver D2WATCHA 팀 블로그뱅크샐러드당근마켓마켓컬리쿠팡" }, { "title": "점프 투 스프링부트", "url": "/posts/jump2springboot/", "categories": "책 리뷰, 점프 투 스프링부트", "tags": "Spring, Spring boot", "date": "2022-08-30 00:00:00 +0900", "snippet": "온라인 책(위키독스)저자 : 박응용https://wikidocs.net/book/7601점프 투 스프링부트점프 투 스프링부트를 정복했다.저자가 머리말에서 “‘코끼리 다리’만 만지지 말고 코끼리를 보자” 라는 말과 같이 세세한 이론 위주의 내용보다는 실습 위주의 내용으로 개발과정 전체를 볼 수 있도록 구성되어 있다.직접 타이핑해 보며 SBB라는 게시판이 완성되어가는 과정을 볼 수 있어서 지루하지 않고 재미있었다.스프링부트에 대해 많이 익숙하지 않았는데 이 책을 계기로 전체적인 구조와 기초적인 내용들을 알 수 있어서 좋았다.처음 스프링부트를 처음 접해보는 사람이라면 가볍게 읽고 실습해 보면서 회원가입, 로그인, 게시판 등 전반적으로 다룰 수 있는 이 책을 추천하고 싶다.하지만 이론적인 부분이 부족하여 다른 책을 더 읽어보며 보충할 예정이다.그리고 책을 보며 실습은 했지만 정리를 하지 않아서 기억에 남는 것이 별로 없는 느낌이다..지금 다시 정리하는 건 되돌아가는 느낌이 들어서 이후에 보는 책들은 조금씩 정리해야겠다는 생각이 들었다." }, { "title": "점프 투 자바", "url": "/posts/jump2java/", "categories": "책 리뷰, 점프 투 자바", "tags": "java", "date": "2022-08-17 00:00:00 +0900", "snippet": "온라인 책(위키독스)저자 : 박응용https://wikidocs.net/book/31점프 투 자바꾸준하게 프로그래밍 책을 읽어야겠다는 생각이 예전부터 있었지만 이제서야 시작하게 되었다.처음부터 딥한 책을 본다면 지칠 것 같아 가볍게 볼 수 있는 책부터 찾았는데 핸드폰으로도 볼 수 있는 온라인 책 위키독스가 눈에 들어왔다.가볍게 읽기 시작했고 예제들은 직접 쳐보고 실행시켜보며 빠른 시간 안에 점프 투 자바를 정독했다.자바를 실무에서 사용하고 있어 익숙한 개념들이 많았고 쭉 훑어보며 복습하기 좋았다.간결하고 매우 깊지는 않게 구성이 되어있지만 핵심이 되는 부분들을 어렵지 않게 풀어내려고 하는 저자의 배려가 느껴졌다.프로그래밍을 처음 배우는 사람들이나 나처럼 가볍게 복습을 원하는 사람들에게 이 책을 추천하고 싶다.다음 책으로는 “점프 투 스프링부트“를 읽고 리뷰를 남기겠다." }, { "title": "Github 블로그 생성", "url": "/posts/hello-github-blog/", "categories": "git, github", "tags": "github, github blog", "date": "2022-08-11 00:00:00 +0900", "snippet": "github 블로그 생성github 블로그를 처음 만들어보았다.1주에 최소 1번은 공부한 내용들을 정리하여 블로그에 올려보자." } ]
