<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://lakhyun-kim.github.io/</id><title>lakhyun.k</title><subtitle>lakhyun, lakhyun.kim, lakhyun.k, Java, Spring</subtitle> <updated>2022-11-10T16:35:55+09:00</updated> <author> <name>lakhyun.kim</name> <uri>https://lakhyun-kim.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://lakhyun-kim.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://lakhyun-kim.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator> <rights> © 2022 lakhyun.kim </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>람다식(Lambda)</title><link href="https://lakhyun-kim.github.io/posts/Lambda/" rel="alternate" type="text/html" title="람다식(Lambda)" /><published>2022-10-28T00:00:00+09:00</published> <updated>2022-10-28T00:00:00+09:00</updated> <id>https://lakhyun-kim.github.io/posts/Lambda/</id> <content src="https://lakhyun-kim.github.io/posts/Lambda/" /> <author> <name>lakhyun.kim</name> </author> <category term="Java" /> <summary> 람다식이란? 메서드를 하나의 식(expression)으로 표현한 것이다. 메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 익명함수라고도 한다. 람다식 도입으로 인해 자바는 객체지향언어인 동시에 함수형 언어가 되었다. int[] arr = new int[5]; Arrays.setAll(arr, (i) -&amp;gt; (int)(Math.random() * 5) + 1); // arr=[1,5,2,1,1] 위에 람다식을 메서드로 표현하면 다음과 같다. int method() { return (int)(Math.random() * 5) + 1; } 간결하면서도 이해하기 쉽고, 오직 람다식 자체만으로도 메서드의 역할을 대신할 수 있다. 게다가 메서드의 매개변수로 전달되어지... </summary> </entry> <entry><title>내부 클래스(inner class)</title><link href="https://lakhyun-kim.github.io/posts/inner-class/" rel="alternate" type="text/html" title="내부 클래스(inner class)" /><published>2022-10-27T00:00:00+09:00</published> <updated>2022-11-04T16:02:26+09:00</updated> <id>https://lakhyun-kim.github.io/posts/inner-class/</id> <content src="https://lakhyun-kim.github.io/posts/inner-class/" /> <author> <name>lakhyun.kim</name> </author> <category term="Java" /> <summary> 내부 클래스란? 내부 클래스는 클래스 내에 선언된 클래스이다. 클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다. class A { // 외부 클래스 // ... class B { // 내부 클래스 // ... } // ... } 내부클래스의 장점 내부 클래스에서 외부클래스의 맴버들을 쉽게 접근할 수 있다. 코드의 복잡성을 줄일 수 있다.(캡슐화) 내부 클래스의 종류와 특징 내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다. 내부 클래스 특징 인스턴스 클래스(instance class) 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클... </summary> </entry> <entry><title>인터페이스(interface)</title><link href="https://lakhyun-kim.github.io/posts/interface/" rel="alternate" type="text/html" title="인터페이스(interface)" /><published>2022-10-26T00:00:00+09:00</published> <updated>2022-10-26T00:00:00+09:00</updated> <id>https://lakhyun-kim.github.io/posts/interface/</id> <content src="https://lakhyun-kim.github.io/posts/interface/" /> <author> <name>lakhyun.kim</name> </author> <category term="Java" /> <summary> 인터페이스란? 인터페이스는 일종의 추상클래스이지만 일반메서드 또는 맴버변수를 가질 수 없고, 오직 추상메서드와 상수만을 맴버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않는다. 추상클래스를 미완성 설계도라고 한다면, 인터페이스는 구현된 것은 아무 것도 없고 밑그림만 그려져있는 기본 설계도라 할 수 있다. 인터페이스의 작성 클래스를 작성하는 것과 같다. 다만 키워드로 class 대신 interface를 사용한다. 그리고 접근제어자로 public 또는 default를 사용할 수 있다. interface 인터페이스이름 { public static final 타입 상수이름 = 값; public abstract 메서드이름(매개변수목록); } 인터페이스 맴버들의 제약사항 모든... </summary> </entry> <entry><title>추상클래스(abstract class)</title><link href="https://lakhyun-kim.github.io/posts/abstract-class/" rel="alternate" type="text/html" title="추상클래스(abstract class)" /><published>2022-10-21T00:00:00+09:00</published> <updated>2022-10-21T00:00:00+09:00</updated> <id>https://lakhyun-kim.github.io/posts/abstract-class/</id> <content src="https://lakhyun-kim.github.io/posts/abstract-class/" /> <author> <name>lakhyun.kim</name> </author> <category term="Java" /> <summary> 추상클래스란? 클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다. 클래스가 미완성이라는 것은 맴버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다. 미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다. 추상클래스는 키워드 abstract를 붙이기만 하면 된다. abstract class 클래스이름 { // ... } 추상클래스는 추상메서드를 포함하고 있다는 것을 제외하고는 일반클래스와 전혀 다르지 않다. 추상클래스에도 생성자가 있으며, 맴버변수와 메서드도 가질 수 있다. 추상메서드(abstract method) 메서드의 ... </summary> </entry> <entry><title>다형성(polymorphism)</title><link href="https://lakhyun-kim.github.io/posts/polymorphism/" rel="alternate" type="text/html" title="다형성(polymorphism)" /><published>2022-10-20T00:00:00+09:00</published> <updated>2022-10-20T00:00:00+09:00</updated> <id>https://lakhyun-kim.github.io/posts/polymorphism/</id> <content src="https://lakhyun-kim.github.io/posts/polymorphism/" /> <author> <name>lakhyun.kim</name> </author> <category term="Java" /> <summary> 다형성이란? 여러 가지 형태를 가질 수 있는 능력을 의미하며 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였고, 상속과 깊은 관계가 있다. 이를 좀 더 구체적으로 말하자면, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다. class Tv { boolean power; // 전원상태(on/off) int channel; // 채널 void power() { power = !power; } void channelUp() { ++channel; } void channelDown() { --channel; } } class CaptionTv extends Tv { String text;... </summary> </entry> </feed>
