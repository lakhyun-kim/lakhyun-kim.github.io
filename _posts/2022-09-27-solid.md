---
title: 객체지향 설계 5대 원칙(SOLID)
author: lakhyun.kim
categories: [Java]
tags: [Java, 객체지향 설계 5대 원칙, SOLID]
pin: false
---

# 객체지향 설계 5대 원칙(SOLID)

**SOLID**란 **로버트 마틴**이 2000년대 초반에 명명한 객체지향 설계의 5대 원칙을 앞 글자만 딴 것이다.

프로그래머가 시간이 지나도 **유지보수**와 **확장이 쉬운** 소프트웨어를 만드는데 이 원칙들을 적용할 수 있다.

1. **S**RP(단일 책임 원칙, Single Responsibility Principle)
2. **O**CP(개방-폐쇄 원칙, Open/Closed Principle)
3. **L**SP(리스코프 치환 원칙, Liskov Substitution Principle)
4. **I**SP(인터페이스 분리 원칙, Interface Segregation Principle)
5. **D**IP(의존관계 역전 원칙, Dependency Inversion Principle)

## SRP(단일 책임 원칙, Single Responsibility Principle)

어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

한 클래스는 하나의 **책임**만 가져야 한다.

<img src = "/assets/img/solid/단일 책임 원칙 1.png">

위에 **남자** 클래스는 **역할과 책임**이 너무 많다.

<img src = "/assets/img/solid/단일 책임 원칙 2.png">

위처럼 **역할과 책임**을 알맞게 분리 시키는 것을 **단일 책임 원칙**을 잘 지켰다고 볼 수 있다.

## OCP(개방-폐쇄 원칙, Open/Closed Principle)

소프트웨어 엔티티(클래스, 모듈, 함수 등)는 **확장**에 대해서는 **열려** 있어야 하지만 **변경**에 대해서는 **닫혀** 있어야 한다.

즉, 자신의 **확장**에는 **열려** 있고, 주변의 **변화**에 대해서는 **닫혀** 있어야 한다.

<img src = "/assets/img/solid/개방 폐쇄 원칙 1.png">

운전자가 마티즈를 운전하다 쏘나타로 자동차를 바꾸면 운전자의 행동에도 수동에서 자동으로 변화가 온다.

<img src = "/assets/img/solid/개방 폐쇄 원칙 2.png">

자동차라는 상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 운전자는 운전 습관에 영향을 받지 않게 된다.

다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 **자신의 확장**에는 **개방**되어 있는 것이고, 운전자 입장에서는 **주변의 변화**에 **폐쇄**되어 있는 것이다.

## LSP(리스코프 치환 원칙, Liskov Substitution Principle)

서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.

- 하위 클래스 is a kind of 상위 클래스 : 하위 분류는 상위 분류의 한 종류이다.
- 구현 클래스 is able to 인터페이스 : 구현 분류는 인터페이스 할 수 있어야 한다.

<img src = "/assets/img/solid/리스코프 치환 원칙 1.png">

아버지 a = new 딸();  // **불가능**(리스코프 치환 원칙 위배)

<img src = "/assets/img/solid/리스코프 치환 원칙 2.png">

동물 a = new 펭귄();  // **가능**(리스코프 치환 원칙 만족)

하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.

## ISP(인터페이스 분리 원칙, Interface Segregation Principle)

클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.

<img src = "/assets/img/solid/인터페이스 분리 원칙 1.png">

각 역할에 맞게 인터페이스로 분리하는 것이다.

ex) 여자친구를 만날 때는 남자친구 역할만 할 수 있게 인터페이스로 제한한다.

결론적으로는 단일 책임 원칙(SRP)과 인터페이스 분리 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.

특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.

**인터페이스 최소 주의 원칙** : 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라.

상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다.

## DIP(의존관계 역전 원칙, Dependency Inversion Principle)

추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.

자주 변경되는 구체(Concrete) 클래스에 의존하지 마라.

<img src = "/assets/img/solid/의존관계 역전 원칙 1.png">

자동차가 타이어에 의존하면 어떻게 될까? 자동차 타이어는 자주 바뀌게 되는 것 중 하나다. 이렇게 자주 바뀌는 것에 의존하면 자동차는 영향을 받게 되어 있다.

즉, 자동차 자신보다 더 자주 변하는 스노우타이어에 의존하기에 좋지 않음을 알 수 있다.

<img src = "/assets/img/solid/의존관계 역전 원칙 2.png">

자동차가 구체적인 타이어가 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 타이어가 변경되어도 자동차가 영향을 받지 않는다.

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 **의존 역전 원칙**이다.

## 출처

[https://p829911.tistory.com/24](https://p829911.tistory.com/24)

[https://devlog-wjdrbs96.tistory.com/380](https://devlog-wjdrbs96.tistory.com/380)
